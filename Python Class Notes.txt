Extension
-------------
py -> Python
ipynb -> Interactive Python Notebook


First Steps
*****************
Literals
=========
- value
- that doesn't need to be interpreted
- obvious, visible, clear

1. Integer literal
-------------------
- A complete number
- No decimal point

age: 25
sugar: 5
hours: 3
walked: 5

examples: 10, -8, 14, 23, 0, -1, 50, -19


2. Floating-point literals
--------------------------
- numbers with decimal point
- floating between two values

weight: 83.4
milk: 0.5
walk: 1.5

example: 5.3, 7.4, 0.0, -11.3, 1.0, -2.0, 3.0

5 and 5.0
3 and 3.0
0 and 0.0


3. Strings (text)
-------------------
- a sequence of characters
- characters are strung together

name: "Omkar"
qualification: "B.Com Computers"
nationality: "Indian"
Gender: "Male"

Identifying text:
--------------------
- Surround it with quotes (single or double)
- Use quotes consistently
- Empty string: "" or ''
- Every character is mapped to a number (Unicode number) and the character is Unicode character.
- space is a character
- They are case-sensitive

A...Z (65...90)
a...z (97...122)

Multi-line strings
-----------------
- surround them triple single or double quotes

"""This is a multiline text"""
'''This is also a multiline text string'''

- They are also called as docstrings as they are used for documentation.


4. Boolean literals
====================
Boolean values: True and False
		: None

- Used to validate a statement/proposition
- Used for decision-making
- Used to control the flow of the program


Operators
============
1. Arithmetic operators
2. Comparison operators
3. Logical operators
4. Text operators (two operators)
5. Assignment operators


Arithmetic Operators
====================
+	Addition
-	Subtraction
*	Multiplication
/	Division
//	Integer (floor) division
%	Remainder (Modulo)
**	Exponent (power)

- Addition, subtraction and multiplication between two integers is an integer.
- Division between two integers is a float.
- Addition, subtraction, multiplication, and division between one float and other can be any value, then the result float.

Operator precedence: PEMDAS
P - Parentheses ()
E - Exponents **
M and D - Multiplication & Division *, /, //, %
A - Addition
S - Subtraction

() Parentheses
[] Brackets
{} Braces

Operator precedence
--------------------
()
**
*, /, //, %
+, -


Comparison (Relational) Operators
==================================
- Use to compare values.
- To relate values
	-> Result is True or False
	-> These operators can also be called Boolean operators

==	Equal to
!=	Not equal
>	Greater than
<	Less than
>=	Greater or equal
<=	Less or equal


100 == 100
True

200 == 100
False

50 != 100
True

50 != 50
False

100 > 10
True

100 > 99.9
True

10 > 100
False

99.9 > 100
False

50 < 80
True

70 < 100
True

99 < 88
False

55 < 1
False

100 >= 100
True

100 >= 99
True

100 >= 200
False

77 >= 25
True

50 <= 200
True

50 <= 50
True

50 <= 10
False

NOTE: Comparison (relational) operators create Boolean expressions, also they create conditions (conditional statements).

Operator precedence
--------------------
()
**
*, /, //, %
+, -
comparison operators



Logical Operators
==================
- Used to combine conditional statements (Boolean expressions)

bool_exp1 logical_operator bool_exp2
logical_operator bool_exp

Three Boolean operators:
- not
- and
- or

The not operator
------------------
not bool_exp

- not is a negation operator
	-> negating is reversing the Boolean expression
	-> Converts True to False, and vice versa.

100 > 50
True

not 100 > 50
False

not True
False

500 < 25
False

not 500 < 25
True

not True
False

not False
True

True
True

not True
False

False
False

not False
True

1 < 2
True

not 1 < 2
False


Class room: 100 students
	program: select 97 students
	one approach: selected names
		name1
		name2
		...
		name97
	second approach: not selected names
		name98
		name99
		name100

Object of 'not' operator is to simplify the work by reversing the order or approach.



The 'and' operator
--------------------
bool_exp1 and bool_exp2
	- When both the Boolean expressions are True, it returns True; otherwise False.

bring pen 'and' paper
to obey my command:
	scenario 1:
		pen only, not paper
	scenario 2:
		paper only, not pen
	scenario 3:
		pen and paper, both
	scenario 4:
		not pen, not paper

JOB NOTIFICATION:
Candidate must be an MBA 'and' must have at least 3yrs of exp
		be1			be2

	be1	and	be2	result
	----	----	----	-------
C1	True	and	True	YES (True)
C2	True	and	False	NO (False)
C3	False	and	True	NO (False)
C4	False	and	False	NO (False)


True and True
True

True and False
False

False and True
False

False and False
False

1 == 1 and 2 == 2
True

1 == 1 and 2 != 2
False

1 != 1 and 2 == 2
False

1 != 1 and 2 != 2
False

True and True and True and True and True
True

True and True and True and False and True
False


The 'or' operator
------------------
bool_exp1 or bool_exp2
	-. The 'or' operator return True when at least one Boolean expression is True; and returns False when all the Boolean are False.


bring pen 'or' marker:
	scenario 1:
		pen only
	scenario 2:
		marker only
	scenario 3:
		pen and marker
	scenario 4:
		brings nothing


JOB NOTIFICATION:
Candidate must be an MBA 'or' must have at least 3yrs of exp
		(be1)			(be2)

	be1	or	be2	Result
	----	----	----	----
C1	True	or	True	YES (True)
C2	True	or	False	YES (True)
C3	False	or	True	YES (True)
C4	False	or	False	NO (False)


True or True
True

True or False
True

False or True
True

False or False
False

1 == 1 or 2 == 2
True

1 == 1 or 2 != 2
True

1 != 1 or 2 == 2
True

1 != 1 or 2 != 2
False

False or False or False or False or True or False or False
True

False or False or False or False or False or False or False
False



Operator precedence
--------------------
()
**
*, /, //, %
+, -
comparison operators
not
and
or


NOTE: True becomes 1 (numeric) and False becomes 0 (numeric) when used in an arithmetic expression.

100 + True
101

100 + False
100


VARIABLES
**********
What is a variable from higher-level view?
- A variable is a container to store a value or an object.

Syntax for creating variables:

var = value
var = object
var = expression
container = value / object / expression

<variable_name> assignment_operator value
(left_side)		=	   (right_side)

= (assignment operator) assigns (stores) the value on the right-side in the variable (container) on the left-side

value: int, float, str, bool
objects: list, tuple, file, etc.
expression: arithmetic, comparison, Boolean 
	Any expression returns a single value:

>>> 100 + 5 - 20 * 3 + (2-4)**4 / 7 * 12 - 400 + 3 * 30
-237.57142857142856


Store values in a variable:

x = 25
y = 30
z = 100

p = "good morning"
q = False
m = 35.7

Update values in a variable:
(When you update with a new value, then old value disappears)

x = 10
x = 20
x = 3.14159
x = 'hyderabad'


Performing operations using variables:

x = 10
y = 20
z = 30

w = x + y + z
w
60

x
10
y
20
z
30


What is the result of comparison expression?
- Result is a Boolean value

What is the object of the 'not' operator?
- Reverse the outcome of a Boolean expression

What are the different types of logical operators?
- They are: not, and, & or

What is a variable in a programming language?
- Container to store a value or an object


Naming variables
================
- Give descriptive names for variables
- A variable shouldn't begin with a number, but it can contain numbers, letters, and underscore (_).

interestRate -> Camel Case
interest_rate -> snake case
InterestRate -> Pascal case

- A variable is case-sensitive
	'A' is not 'a'
- A variable name shouldn't contain spaces
- Don't use keywords for variable names


Compound Assignment Operators
==============================
+=
	- Add a value to a variable and then assign the new value by updating variable value.

x = 1
x += 1


-=
	Subtract a value from a variable and then assign the new value to update the variable value.


*=
	Multiplies the value with the new value and assigns back to the variable.

/=
	Divides the existing value with the new value and assigns the result to the variable.


Line Continuation character - \
=================================
Wherever you want to break a statement into the next line, type '\' line continuation character and then hit 'Return' key.

Comments
===========
Comments are written inside a program. But the don't affect the code. They are a kind of documentation for reviewing the code.
Comments are ignored by the interpreter.
We can write comments on independent lines or inline comments which we at the end of the statement.

Comments begin with hash tag (#)


SEVEN ESSENTIAL FUNCTIONS
**************************
1. type(value/object)
	Returns the class/type of the specified 'value/object'.

2. print([data][, sep=" "][, end="\n"])
	Prints data to the console/shell.

In syntax:
	- anything surrounded by brackets [] is optional most of the time. Optional: data, sep, and end are optional parameters.

Without parameters print() prints an empty line.

Arguments or parameters are separated by comma (,).

[data]	- optional
	- data can be more that one argument to be printed

[sep]	- optional
	- its default value is space " "

[end]	- optional
	- it's default value is new line (\n) character
	- character/string is printed after the last parameter 

Note: "\n" for new line character and "\t" for tab character


3. var = input([prompt])

- Adds interactivity to the program

The input() function:
	waits for the user input
	when user inputs and hits Return key
	converts the input to a string
	then finally assigns it to a var on the left-side

[prompt]	- optional
		- friendly text to guide the end user


4. int(value)
	Converts the specified value (str) to an integer provided the value contains only numeric characters, not even comma and dot.

func( func( func( ) ) )


5. float(value)
	Converts the specified value (str) to a floating-point number provided the value contains only numeric characters and additionally may contain one dot (decimal point).


6. str(value)
	Converts the specified value to a string.

7. round(num[, deci_places])
	Rounds the specified 'num' to the nearest integer.
	Additionally, we can have specific number of deci_places.



String operations
=================
1. Concatenation (text joining)
	+ -> concatenation operator

2 Repeat operator
	* -> repeating a string
	str * int



CONSTRUCTS - To statements into a single unit (blocks of units)
================================================================
Examples: if, for, while, def, class, with, etc.


The if statement (construct)
============================
- Conditional 'Branching' Construct
	- helps to choose one branch or no branch from several branches
	- the choice made based on a condition

Syntax for 'if' statement:
---------------------------
Three clauses: if, elif, else
Block: set of statements which are indented
	indentation is required to imply the statements are part of that particular clause
	all the statements must be equally indented
	removing indentation ends the clause / construct

if bool_exp:
	block
[elif bool_exp:
	block]...
[else:
	block]


if - required clause (1)
elif - optional clause (0 to n)
else - optional clause (0 to 1)


bool_exp
	returns True or False
	- condition, comparison, logical expression, Boolean value, functions (is functions).


if -> [elif] -> [else]

else clause:
	-> the block of else clause is executed only when statements from no clause are executed.


LOOP CONSTRUCTS
*****************
- Executes a block repeatedly
- Two types of loops: 'for' and 'while'
- The 'for' loop
	- collection (countable) loop
	- finite loop
	- each execution of the block is called an iteration
	- for each item in a collection the loop execute the block once

The 'for' loop
***************

Syntax for 'for' construct:

for <var> in <collection>:
	block


for x in [100, 97, 85, 77]:
	print("Great!!")


Additive Identity: 0
Multiplicative Identity: 1
String Identity: ""
Creating collection: []


total = 0
for i in [1, 2, 3, 4, 5]:
    total = total + i

total = 0

i = 1
total = total + i
total = 1

i = 2
total = total + i
total = 3

i = 3
total = total + i
total = 6

i = 4
total = total + i
total = 10

i = 5
total = total + i
total = 15

# Series
---------
AP
GP
HP

1, 2, 3, 4, 5, 6, 7, ..., 10, ..., 100, ..., 50000
2, 5, 8, 11, 14, ...
-3, 0, 3, 6, 9, ...
2, 4, 8, 16, 32, 64, ....
1/2, 1/6, 1/10, 1/14, ....


The range() function/iterator
******************************
Syntax
---------
range([start=0,] stop[, step=1])
	-> this is a pure iterator function
	-> starts giving values from 'start' value till 'stop' value, stop is exclusive, from 'start' to reach 'stop' the function continuously adds 'step' value.

By default, start is 0 and step is 1


range(stop)	-> stop > 0
----------------------------
range(5)	# 0, 1, 2, 3, 4
range(8)	# 0, 1, 2, 3, 4, 5, 6, 7
range(3)	# 0, 1, 2
range(-7)	# wrong


range(start, stop)	-> start < stop
----------------------
range(0, 4)	# 0, 1, 2, 3
range(1, 5)	# 1, 2, 3, 4
range(8, 14)	# 8, 9, 10, 11, 12, 13
range(-3, 3)	# -3, -2, -1, 0, 1, 2
range(-9, -6)	# -9, -8, -7
range(3, -3)	# wrong


range(start, stop, step)
-------------------------
start < stop	step: +ve
start > stop	step: -ve

range(1, 20, 6)		# 1, 7, 13, 19
range(-50, 50, 20)	# -50, -30, -10, 10, 30
range(50, -50, 20)	# wrong
range(10, 100, -30)	# wrong
range(-50, -10, 20)	# -50, -30
range(-30, 30, -8)	# wrong
range(-30, 30, 8)	#


The 'while' loop
*****************
- This loop is an infinite loop
- Runs indefinitely
- More efficient that 'for' loop

while bool_exp:
	block

As long as the bool_exp is True the loop iterates; once the bool_expression becomes False the loop ends.
Before every iteration it checks the condition. If the condition is True then it iterates, False then ends the loop.


for i in range(5):
	print(i, end=" ")

range(0, 5, 1)	start: 0, stop: 5, step: 1


i = 0
while i < 5:
	print(i, end=" ")
	i += 1


0! = 1
1! = 1
2! = 1 x 2 = 2
3! = 1 x 2 x 3 = 6
4! = 1 x 2 x 3 x 4 = 24
5! = 1 x 2 x 3 x 4 x 5 = 120


n = 5
fact = 1
for i in range(1, n+1):
	fact *= i
print("Factorial:", fact)


n = 5
fact = 1
i = 1
while i < n + 1:
	fact *= i
	i += 1
print("Factorial:", fact)


n = int(input("Enter a positive integer: "))
fact = 1
if n == 0 or n == 1:
	fact = 1
	print("Factorial:", fact)
elif n > 1:
	for i in range(1, n+1):
		fact *= i
	print("Factorial:", fact)
else:
	print("We need a positive integer.")


Electrical Units - Current Bill
===============================
1 to 100 ->  1 rupee / unit
101 to 200 -> 2 rupees / unit
201 to 300 -> 3 rupees / unit
301 to 400 -> 4 rupees / unit
400 +	   -> 5 rupees / unit


305 units used
	100 x 1 = 100
	100 x 2 = 200
	100 x 3 = 300
	5 x 4   =  20


Write a program to calculate bill for the specified units


The 'break' statement
======================
- Sometimes we need to stop iterating a loop. Breaking a loop early (prematurely).
- When the loop does what it is intended for then we can break the loop without going through all the iterations.
- We need to break the loop for a reason (condition), which is specified by 'if' statement.
- Use 'break' statement to break a loop

loop
-> if
   -> break


The 'continue' statement
==========================
- Sometimes we need to skip an iteration, means we don't need execute all the statements of a block.
- The 'continue' statement skips an iteration and jumps to the beginning of the loop, to the next iteration.
- Always use the 'continue' statement inside a 'if' statement.

loop
-> if
   -> continue


FUNCTIONS
***********
Built-in functions
	func_name()
Standard Library functions
	module_name.func_name()
Third-party library functions
	library_name.func_name()
	library_name.module_name.func_name()
	library_name.module_name.class_name.func_name()
	library_name.class_name.func_name()
	library -> [module] -> [class] -> [func]
User-Defined Functions (UDFs)

Why functions?
--------------
- To avoid repeating
- To divide a program into smaller parts
- To automate tasks
- To reuse


Syntax:

def func_name([args]):
	block


'def' - to define a function
func_name - name that you give to a function, its same as naming variables
[args]  - args is arguments (optional)
	- args are variable that take inputs from the function call
	- args are inputs provided to the function
block	- statements

To execute a function we need to make a call to the function:
# function call
func_name([args])


Named functions
===============
def voting(name, age):
	print(f"Hello, {name}!")
	if age >= 18:
		print("You can vote.")
	else:
		print(f"Wait for {18-age} year(s).")

# calling function with arguments
voting("Rajesh", 35)

# calling using named arguments
voting(age=35, name="Rajesh")


Optional (default) parameters (arguments)
===========================================
In the function definition, if we set a parameter to a value then that parameter become optional with default value.
When there are parameters in a sequence make last parameters as default parameters.

We can override the default parameter value by provide a value for it. Otherwise it goes with the default value.


The 'return' statement
=======================
So far, function received inputs through arguments of a calling statement. But functions didn't return anything to the calling statement.

We use 'return' statement inside the function to return a value or an object back to the calling statement. And the calling statement will be replaced by the returned value or object.
The 'return' statement ends the function execution.

In real-world applications, most function have 'return' statement coded.




def func1(args):
	func2(args)

def func2(args):
	...

func1(args)


Local and Global Variables
==========================
Global variable:
- Any variable is created outside of any function.
- It can be read (get its value) and written (change/set its value) out side of functions.
- Inside a function its read-only.
- By default, global is accessible every where.
- Using the keyword 'global' we can modify a global inside a function, which is not recommended.

var1 = 0	# global vairable
var1 = 8

def func1():
	var1	# can't change it
	...

def func2():
	var1 = 30	# a new local variable
	...

def func3():
	global var1	# not recommended
	...

var2 = 100	# global variable
var1 = 16
var2 = 99


Local variable:
-------------------
Any variable created inside a function.
Its only accessible inside a function.




def sample():
    print(x)    # global

x = 25  # global
sample()

###########

def sample():
    x = 15      # local
    print(x)    # local

x = 100     # global
sample()
print(x)    # global; prints 100

##########

def sample(x):  # local
    print(x)    # local

x = 50          # global
sample(x)       # global
print(x)        # global

##########

def sample(x, y):       # local x, y
    z = x + y           # local z
    print("Result:", z) # local z

res = sample(10, 20)        # global: res
print("The result is sent back:", res) # global: res

##########

def sample():
    global x    # global: not recommended   
    x = 35      # global

x = 100         # global
sample()
print(x)        # global; x is 35

###########


Module
==========
What is a module in Python?
- A python file with .py extension
- File: temperature.py
- Module: temperature

Modules contain function(s). These modules can be imported to reuse the functions residing in them.

def to_fahrenheit(celsius):
	fahrenheit = (celsius * 9/5) + 32
	return fahrenheit

def to_celsius(fahrenheit):
	celsius =  (fahrenheit - 32) * 5/9
	return celsius



Importing a module
------------------
import module_name
import temperature

We can also import a module with a shorter name, called alias name using 'as' keyword.

import module_name as mn
import temperature as t

How to use function from a module
------------------------------------
import module_name
module_name.func_name([args])

import temperature
temperature.to_celsius(100)

import temperature as t
t.to_celsius(150)

Directly importing function from a module is not recommended.

from module_name import func_name1, func_name2, ...
from module_name import *	# all functions
func_name1([args])		# not recommended


Standard Library Modules
-------------------------
1. random: functions to generate random numbers
2. csv: functions to work with csv files
3. pickle: functions to work with persistent data
4. math: functions for mathematical operations
5. datetime: contains functions to work with data, time, and datetime, additionally timedelta
6. decimal: to create and work with decimal numbers
7. json: to work with json file

The 'random' module
===================
- Contains functions to generate random numbers
- Import the module:
	import random

random()
---------
Returns a random value between 0 and 1, 1 is exclusive.

>>> random.random()
0.6165319594361989
>>> random.random()
0.3152381192062611
>>> random.random()
0.575182095960144
>>> random.random()
0.1986863126427959


randint(min, max)
------------------
Returns number between min and max values, including min and max value.

>>> random.randint(3, 5)
5
>>> random.randint(3, 5)
4
>>> random.randint(3, 5)
5
>>> random.randint(3, 5)
3
>>> random.randint(3, 5)
5


randrange(start, stop[, step])
---------------------------------
- Similar to range() function, but not iterator, it gives number from the range randomly. The 'stop' is exclusive.

>>> random.randrange(2, 11, 2)
8
>>> random.randrange(2, 11, 2)
2
>>> random.randrange(2, 11, 2)
2
>>> random.randrange(2, 11, 2)
6
>>> random.randrange(2, 11, 2)
6
>>> random.randrange(2, 11, 2)
6
>>> random.randrange(2, 11, 2)
8


pi value from 'math' module
============================
Import module:
	import math

>>> import math
>>> math.pi
3.141592653589793



COLLECTIONS
================
There are two types of collections:
- Ordered (sequences)
- Unordered 


List
******
- List is a collection of ordered items. List is a sequence.
- A list is mutable object. A list can be changed.
- A list can contain duplicate items. List is not a set.

Syntax for creating a list
---------------------------
[item1, item2, item3, item4, ...]
mylist = [item1, item2, item3, item4, ...]

- items can be of any datatype

>>> temps = [32.7, 25.9, 35.3, 30.9, 32.0]
>>> temps
[32.7, 25.9, 35.3, 30.9, 32.0]
>>> scores = [99, 100, 85, 77, 29, 88]
>>> scores
[99, 100, 85, 77, 29, 88]
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names
['raju', 'anand', 'shiva', 'charan']
>>> emp_details = ["raju", "1003", 35, "hr", "hyd", 38000.0, 2, True]
>>> emp_details
['raju', '1003', 35, 'hr', 'hyd', 38000.0, 2, True]


>>> # empty list
>>> marks = []

>>> # a list with default values
>>> sub_scores = [0] * 6
>>> sub_scores
[0, 0, 0, 0, 0, 0]


Accessing items from a list
============================
As list is a sequence, so the items are referred using index numbers.
First item index is 0, second item index is 1, third item index is 2, so on and so forth.
We can also refer items from last to first, last item index is -1, second last item index is -2, third last item index is -3, so on and so forth.

Syntax for accessing item in a list
------------------------------------
list_name[index_number]		# [] is index operator



emp_names = ["raju", "anand", "shiva", "charan"]
emp_names[0]
'raju'
emp_names[1]
'anand'
emp_names[2]
'shiva'
emp_names[3]
'charan'
emp_names[4]
Traceback (most recent call last):
  File "<pyshell#72>", line 1, in <module>
    emp_names[4]
IndexError: list index out of range


>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names[-1]
'charan'
>>> emp_names[-2]
'shiva'
>>> emp_names[-3]
'anand'
>>> emp_names[-4]
'raju'
>>> emp_names[-5]
Traceback (most recent call last):
  File "<pyshell#79>", line 1, in <module>
    emp_names[-5]
IndexError: list index out of range


Objects: int, float, str, bool, list, tuple, set, dict, array, file, ...


#######################
Objects:
	attributes: characteristics, features
	methods: functions, actions

human:
	ATTRIBUTES: variables
	name = "anand"
	age = 25
	gender = "male"
	nationality = "Indian"
	ethnicity = "Asian"
	weight = 53
	height = 165
	color = "wheatish"
	education = "graduate"
	METHODS: functions
	run(direction, duration, speed)
	walk(time, type, duration)
	sit(location, com_type, ...)
	eat(num, type, amount, nutrition, calories, ...)
	read(genre, purpose, notes, ...)
	jump(height, num, ...)

book:
	ATTRIBUTES:
	author = "satish"
	publisher = "wiley"
	year = 2026
	pages = 385
	chapters = 12
	book_type = "hardbound"
	genre = "non-fiction"
	METHODS:
	open()
	bookmark()
	foldpage()
	tearpage()

Using attributes and methods of an object:
	object.attribute 	-> value
	book.author		-> satish
	object.attribute = newValue
	book.publisher = "routledge"
	object.method([args])

Difference between method and function:
function(object)	# object is an input
object.method()		# operates on input

#######################

Set a new item in the place of an existing item
-----------------------------------------------
my_list[index] = newItem

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names[0] = "prasad"
>>> emp_names
['prasad', 'anand', 'shiva', 'charan']
>>> 



Methods of a list object
=========================
1. append(item)
	Appends the specified item to the end of the list.

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names.append("omkar")
>>> emp_names
['raju', 'anand', 'shiva', 'charan', 'omkar']
>>> emp_names.append("satish")
>>> emp_names
['raju', 'anand', 'shiva', 'charan', 'omkar', 'satish']
>>> emp_names.append("akanksha")
>>> emp_names
['raju', 'anand', 'shiva', 'charan', 'omkar', 'satish', 'akanksha']
>>>


2. insert(index, item)
	Inserts the specified item at the specified index.

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names.insert(1, "manoj")
>>> emp_names
['raju', 'manoj', 'anand', 'shiva', 'charan']
>>> 
>>> emp_names.insert(0, "omkar")
>>> emp_names
['omkar', 'raju', 'manoj', 'anand', 'shiva', 'charan']
>>> emp_names.insert(4, "akanksha")
>>> emp_names
['omkar', 'raju', 'manoj', 'anand', 'akanksha', 'shiva', 'charan']
>>>



3. index(item)
	Returns the index number of the first occurrence of the specified item.


>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan", "raju", "anand", "raju", "shiva"]
>>> 
>>> emp_names.index("raju")
0
>>> emp_names.index("anand")
1
>>> emp_names.index("charan")
3
>>>


4. remove(item)
	Deletes the first occurrence of specified item.

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan", "raju", "anand", "raju", "shiva"]
>>> emp_names.remove("raju")
>>> emp_names
['anand', 'shiva', 'charan', 'raju', 'anand', 'raju', 'shiva']
>>> emp_names.remove("anand")
>>> emp_names.remove("charan")
>>> emp_names.remove("rajesh")
Traceback (most recent call last):
  File "<pyshell#139>", line 1, in <module>
    emp_names.remove("rajesh")
ValueError: list.remove(x): x not in list
>>>


5. pop([index])
	Removes the last item if the index is not specified.
	If the index is specified then it removes item at the specified index.
	Before it removes the item it returns the item and then removes it.


>>> 
>>> cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
>>> cities.pop()
'mum'
>>> cities
['hyd', 'amr', 'che', 'blr', 'tri']
>>> 
>>> cities
['hyd', 'amr', 'che', 'blr', 'tri']
>>> 
>>> removed_item = cities.pop()
>>> removed_item
'tri'
>>> 
>>> cities
['hyd', 'amr', 'che', 'blr']
>>> 
>>> cities.pop(2)
'che'
>>>


The 'len()' function
====================
len(collection)
	counts the number of items in the collection and returns that number.

>>> 
>>> cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
>>> 
>>> len(cities)
7
>>>



'in' - membership keyword
=========================
Syntax
---------
item in list
	If 'item' in 'list' it returns True; otherwise False.


item in tuple
sub_str in str



cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
"hyd" in cities
True
"che" in cities
True
"del" in cities
False
"kol" in cities
False


if "hyd" in cities:
    print("Hyderabad is in the list")
else:
...     cities.append("hyd")
... 
...     
Hyderabad is in the list
>>> 
>>> if "kol" in cities:
...     print("Kolkatta is in the list")
... else:
...     cities.append("kol")
...     print("Kolkatta is added")
... 
...     
Kolkatta is added
>>> cities
['hyd', 'amr', 'che', 'blr', 'tri', 'mum', 'bhu', 'kol']
>>>


Looping through the items in a list
====================================
for item in list:
	block

>>> 
>>> cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
>>> 
>>> for city in cities:
...     print(city, end=" ")
... 
...     
hyd amr che blr tri mum bhu 
>>>


List of lists
================

One employee:
["anand", 20, "hr", 22000.0, "suryapet", False]


More that one employee: list of lists:
[
["anand",  85, 80, 75],
["shiva",  88, 90, 80],
["omkar",  75, 85, 95],
["satish", 80, 90, 70],
["manoj",  80, 80, 80],
]

To refer items in the list use index as usual:
list[index]
To refer items in the sublists use index of index:
list[index][index]



>>> student_marks[0]
['anand', 85, 80, 75]
>>> student_marks[0][0]
'anand'
>>> 
>>> student_marks[1]
['shiva', 88, 90, 80]
>>> student_marks[1][0]
'shiva'
>>> student_marks[1][1]
88
>>> student_marks[1][2]
90
>>> student_marks[1][3]
80
>>>


More list methods
*******************
1. count(item)
	-> Counts the number of occurrences of the specified item in the list, and returns the number.


>>> 
>>> students = ["praveen", "naveen", "suresh", "naveen", "uday", "naveen", "suresh"]
>>> 
>>> students.count("praveen")
1
>>> students.count("naveen")
3
>>> students.count("suresh")
2
>>> students.count("anand")
0
>>>


2. reverse()
	- Reverses the order of items in a list.

>>> 
>>> students = ["praveen", "naveen", "suresh", "naveen", "uday", "naveen", "suresh", "krishna", "srinu", "anil", "prasad"]
>>> 
>>> students.reverse()
>>> students
['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen']
>>> 


3. sort([key=function][, reverse=False])
	Sort the items in a list by default is ascending order.
	Additionally, we can specify a function before sorting the items using 'key' parameter.
	Use the 'reverse' parameter for ascending and descending.


>>> 
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> students.sort()
>>> students
['Mahesh', 'anil', 'krishna', 'naveen', 'naveen', 'naveen', 'prasad', 'praveen', 'srinu', 'suresh', 'suresh', 'uday']
>>> 


>>> 
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> students.sort(key=str.lower)
>>> students
['anil', 'krishna', 'Mahesh', 'naveen', 'naveen', 'naveen', 'prasad', 'praveen', 'srinu', 'suresh', 'suresh', 'uday']
>>> 

>>> 
>>> students.sort(key=str.lower, reverse=True)
>>> students
['uday', 'suresh', 'suresh', 'srinu', 'praveen', 'prasad', 'naveen', 'naveen', 'naveen', 'Mahesh', 'krishna', 'anil']
>>> 




The built-in function: sorted(list[, key=function])
====================================================
- This function returns a new sorted list.

>>> 
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> students_sorted = sorted(students, key=str.upper)
>>> students_sorted
['anil', 'krishna', 'Mahesh', 'naveen', 'naveen', 'naveen', 'prasad', 'praveen', 'srinu', 'suresh', 'suresh', 'uday']
>>> students
['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', 'Mahesh']
>>> 


Two built-in functions: min() & max()
======================================
- Find the min and max values from a numeric list.


>>> 
>>> numbers = [10, 8, 25, 10, 15, 75, 1]
>>> min(numbers)
1
>>> max(numbers)
75
>>> 


choice() function from random module
====================================
- This function chooses one item randomly from the list.

import random
random.choice(list)


>>> 
>>> import random
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> random.choice(students)
'naveen'
>>> random.choice(students)
'suresh'
>>> random.choice(students)
'suresh'
>>> random.choice(students)
'naveen'
>>> random.choice(students)
'naveen'
>>>


shuffle() function from random module
======================================
- It shuffles the items randomly in a list

import random
random.shuffle(list)



import random
students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]

random.shuffle(students)
students
['srinu', 'krishna', 'prasad', 'praveen', 'anil', 'naveen', 'Mahesh', 'suresh', 'naveen', 'suresh', 'naveen', 'uday']
>>> 
>>> random.shuffle(students)
>>> students
['prasad', 'suresh', 'praveen', 'naveen', 'naveen', 'suresh', 'uday', 'srinu', 'krishna', 'naveen', 'anil', 'Mahesh']
>>> random.shuffle(students)
>>>
>>> students
['naveen', 'prasad', 'naveen', 'suresh', 'krishna', 'anil', 'suresh', 'praveen', 'srinu', 'naveen', 'Mahesh', 'uday']
>>> 
>>> random.shuffle(students)
>>> students
['srinu', 'suresh', 'krishna', 'naveen', 'prasad', 'anil', 'naveen', 'Mahesh', 'naveen', 'praveen', 'uday', 'suresh']
>>>


List copying
================
Two types:

- Shallow copy
	In shallow copy we assign a list to a variable and then we assign that variable to a new variable. Now, both the variables point to the same list.
	This is called shallow copy.


# shallow copy
a = [1, 2, 3]
b = a
a
[1, 2, 3]
>>> b
[1, 2, 3]
>>> 
>>> a.append(4)
>>> a
[1, 2, 3, 4]
>>> b
[1, 2, 3, 4]
>>> a.append(5)
>>> b.append(6)
>>> a
[1, 2, 3, 4, 5, 6]
>>> b
[1, 2, 3, 4, 5, 6]
>>> 


- Deep copy
	Deepcopy is created using the deepcopy() function from copy module.
	Deepcopy is a actually a separate copy of a list.



import copy
>>> m = [1, 2, 3]
>>> n = copy.deepcopy(m)
>>> 
>>> m.append(4)
>>> m
[1, 2, 3, 4]
>>> n
[1, 2, 3]
>>> 
>>> n.append(40)
>>> n
[1, 2, 3, 40]
>>> m
[1, 2, 3, 4]
>>> 


Slicing a list
================
my_list[start:end:step]
	start is 0 (by default)
	step is 1 (by default)
	end is exclusive


>>> numbers = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]
>>> 
>>> numbers[0:5]
[5, 10, 15, 20, 25]
>>> numbers[0:]
[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]
>>> numbers[0::2]
[5, 15, 25, 35, 45, 55]
>>> numbers[1::2]
[10, 20, 30, 40, 50, 60]
>>> numbers[1:-1:3]
[10, 25, 40, 55]
>>> numbers[::-1]
[60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 5]
>>> 



Concatenating lists
====================
books1 = ["Attitude", "Leadership", "Management"]
books2 = ["Python" "Power BI", "Excel"]

books = books1 + books2

>>> 
>>> books1 = ["Attitude", "Leadership", "Management"]
>>> books2 = ["Python", "Power BI", "Excel"]
>>> books = books1 + books2
>>> 
>>> books
['Attitude', 'Leadership', 'Management', 'Python', 'Power BI', 'Excel']
>>> 


# extending a list using concatenation
>>> 
>>> books1 += books2
>>> books1
['Attitude', 'Leadership', 'Management', 'Python', 'Power BI', 'Excel']
>>> 




WORKING WITH TUPLES
********************
- Tuple is a sequence of items like a list object.
- Unlike list, tuple is immutable, you cannot:
	- change items
	- add items
	- delete items
	- reverse the items
	- sort the items
- Syntax for tuple:

(item1, item2, item3, ... )
my_tuple = (item1, item2, item3, ... )




>>> products = ("saving", "fd", "rd", "insurance", "bonds")
>>> # append doesn't work
>>> products.append("vehicle insurance")
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    products.append("vehicle insurance")
AttributeError: 'tuple' object has no attribute 'append'
>>> # pop doesn't work
>>> products.pop()
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    products.pop()
AttributeError: 'tuple' object has no attribute 'pop'
>>> # assignment to an item doesn't work
>>> products[0] = "savings"
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    products[0] = "savings"
TypeError: 'tuple' object does not support item assignment
>>> 
>>> 


Accessing item of a tuple
==========================
- Use the index number to access the items of a tuple.
- Index 0 is first item, index 1 is second item, index 2 is third item, so on and so forth.
- Index -1 is last item, index -2 is second last item, index -3 is third last item, so on and so forth.




products
('saving', 'fd', 'rd', 'insurance', 'bonds')
products[0]
'saving'
products[1]
'fd'
products[3]
'insurance'
>>> products[-1]
'bonds'
>>> products[-2]         
'insurance'
>>>


>>> 
>>> # count(item) to count the specified
>>> products.count("insurance")
1
>>> 
>>> # my_tuple[start:end:step] - slicing
>>> products[1:]
('fd', 'rd', 'insurance', 'bonds')
>>>



Unpacking items in a list/tuple
*******************************
If a list/tuple contains 10 items, then you can assign them to 10 variable using one single statement.



>>> products = ("laptop", "printer", "scanner", "webcam")

>>>> p1, p2, p3, p4 = products
>>> p1
'laptop'
>>> p2
'printer'
>>> p3
'scanner'
>>> p4
'webcam'
>>> 
>>> 
>>> weekdays = ["mon", "tue", "wed", "thu", "fri"]
>>> w1, w2, w3, w4, w5 = weekdays
>>> w1
'mon'
>>> w2
'tue'
>>> w3
'wed'
>>> 
>>> 


The list() function
===================
- Creates a new list object based on the given object.

>>> 
>>> products = ("laptop", "printer", "scanner", "webcam")
>>> products_list = list(products)
>>> products_list
['laptop', 'printer', 'scanner', 'webcam']
>>> 
>>> 

The tuple() function
====================
- Creates a new tuple object based on the given object.

>>> 
>>> weekdays = ["mon", "tue", "wed", "thu", "fri"]
>>> weekdays_tuple = tuple(weekdays)
>>> weekdays_tuple
('mon', 'tue', 'wed', 'thu', 'fri')
>>> 


WORKING WITH FILES
********************
In Python, there are two types of files:
	- text files
	- binary files

Text files
-----------
- A text file is a sequence of lines, each line contains characters, at the end of each line there is new line (\n) character.
- .txt, .csv, .html, .xml, .json


Binary files
------------
- A binary file is a sequence of bytes. And it may contain text parts.
- image, voice, video, compressed, compiled, etc.


Text files
***********
File operations
=================
1. Open the file
	- Use the built-in function: open()
2. Read from the file or write to the file
	- To read there are read methods
	- To write we have write() method
3. Close the file
	- Use the close() method

Note: Always close the file which opened.


.	current folder
..	parent folder

project/
	files/
		hello.txt
		docs/
	access_file.py
	test_scenarios.txt



access_file.py
	. (current folder)	project/
	./files			project/files
	./files/hello.txt	project/files/hello.txt
	../			parent folder of project
	test_scenarios.txt	Right
	./test_scenarios.txt	Appropriate (practical)

The open() function
********************
Syntax
-----------
open(file, mode)
	- This function opens the specified file in the specified mode and returns a file object.
	- We use the file object to read and write data.
	- file: file_name (may include path)
	- mode: specifies how we can work the file


File modes of open() function
------------------------------
1. r (read) mode
	- We can read the file if it exists. If the file does not exist, then it throws FileNotFoundError.

2. w (write) mode
	- If the file doesn't exist it creates a new file
	- If the file already exists then it erases all the data from the file
	- Then we can write new data

3. a (append) mode
	- If the file doesn't exist then it creates a new file
	- If the file already exists then we can append the new data to the end of the file.

4. b (binary) mode
	- Use binary mode (b) with read (rb) and write (wb) mode



Reading a file using 'for' loop
================================
- A file is a sequence of lines, so we can loop through each line in a file.

file1 = "courses.txt"
for line in file1:
	print(line)


There are three read methods
=============================
1. read()
	This method reads entire file as one single string.
2. readlines()
	This method reads entire file into a list, where each item is a line from the list.
3. readline()
	This method reads the next line.



The 'with' to automatically close a file
=========================================
The 'with' statement creates a content, and the content ends when the block ends.

with ...:
	block

The 'with' is used to close the file automatically as the file opened with the 'with' statement closes when the block ends.



years = [2021, 2022, 2023, 2024, 2025]

years.txt
----------
2021
2022
2023
2024
2025

years = [2021, 2022, 2023, 2024, 2025]


Three other types
===================
binary 	-> use 'pickle' module
csv	-> use 'csv' module
	-> pandas contains read_csv() method
json	-> use 'json' module
	-> pandas contains read_json() method





WORKING WITH NUMBERS
**********************
Floating numbers are approximate numbers.
So we need to use Decimal numbers.
From the 'decimal' module import 'Decimal' construct to construct decimal numbers.


Rule
-------
Decimal + int	  -> legal
int + float	  -> legal
Decimal + float	  -> illegal


total = 100
discount = 10
after_discount = 90
tax = 18% (16.2)

invoice_total = after_discount + tax


Formatting numbers
**********************
format()	-> formats a number and converts it to a string
format-specification	-> to specify how to format a number (data_item)

Syntax
--------
"...{:format-specification}...".format(data_item)

"...{:format-specification}...{:format-specification}...".format(data_item1, data_item2)


Rule
-------
numbers are aligned right
text is aligned left

Format-specification
--------------------
[alignment-char][width][comma][.deci_places][type_code]


alignment-char:
	> right-alignment
	< left-alignment
	^ center-alignment

type_code:
	d - integer
	f - float
	% - percentage
	e - exponent


Product		 Units		    Price
-------		-------		  -------
Laptop		     8		48,000.00
Printer		    12		 8,500.00
Webcam              80		   999.00
Scanner              3		10,995.00


print("{:14} {:>7} {:>13}".format("Product", "Units", "Price"))
print("{:14} {:>7} {:>13}".format("-------", "-------", "-------"))
print("{:14} {:7d} {:13,.2f}".format("Laptop", 8, 48000))
print("{:14} {:7d} {:13,.2f}".format("Printer", 12, 8500))
print("{:14} {:7d} {:13,.2f}".format("Webcam", 80, 999))
print("{:14} {:7d} {:13,.2f}".format("Scanner", 3, 10995))


WORKING WITH STRINGS
*********************
- A sequence of characters

- To get Unicode number of a specified character use: ord(char)
- To get character using specified Unicode numbers: chr(num)


chr(3077)
'అ'
chr(3078)
'ఆ'
>>> chr(3079)
'ఇ'
>>> 
>>> chr(177)
'±'
>>> chr(169)
'©'
>>> 
>>> ord("A")
65
>>> ord("a")
97
>>> ord("-")
45
>>> 


1. len(string)
	- counts the number of characters in a string and returns the count number.

>>> len("Hello, world!")
13


Getting a character from a string
----------------------------------
- Using index number to a get a specific character from a string, these index numbers are similar to list's index numbers.



>>> str1 = "Congratulations!"
>>> str1[0]
'C'
>>> str1[1]
'o'
>>> str1[2]
'n'
>>> 
>>> str1[-1]
'!'
>>> str1[-2]
's'
>>> str1[-3]
'n'
>>> 


Slicing a string
================
my_string[start:end:step]

>>> 
>>> msg = "How I wish I could calculate"
>>> msg[0:3]
'How'
>>> msg[4:5]
'I'
>>> msg[6:10]
'wish'
>>> msg[::2]
'HwIws  ol aclt'
>>> msg[1::2]
'o  ihIcudcluae'
>>> msg[::-1]
'etaluclac dluoc I hsiw I woH'
>>> 


Triple quotes for multiline string
==================================
- This is generally used to store SQL queries and sometimes commands in the form text inside a program (code).


SQL_query_1 = """SELECT *
FROM products"""


'in' keyword to check a substring inside a larger string
=========================================================
substring in string
	- If the substring in string then it returns True; otherwise False

>>> 
>>> msg = "Congratulation! You won one million dollars!!"
>>> "on" in msg
True
>>> "mill" in msg
True
>>> "ion" in msg
True
>>> "now" in msg
False
>>> "billion" in msg
False
>>> 


if substring in string:
	block


>>> 
>>> if "million" in msg:
...     print("You have won a million dollars!")
... else:
...     print("You have won a billion dollars!")
... 
...     


Looping over characters in a string
------------------------------------

for char in string:
	block

>>> 
>>> for c in "hello":
...     print(c)
... 
...     


String Methods
================
1. isalpha()
	Returns True if all the characters are letters; otherwise False.


>>> 
>>> "hello".isalpha()
True
>>> "HELLO".isalpha()
True
>>> "Hello".isalpha()
True
>>> "hello1".isalpha()
False
>>> "hello ".isalpha()
False
>>>


2. islower()
	Returns True if all the letters are in lower-case; otherwise False.


>>> 
>>> "hello123".islower()
True
>>> "hello-;1_".islower()
True
>>> "helloA".islower()
False
>>> 


3. isupper()
	Returns True if all the letters are in uppercase; otherwise False.


>>> 
>>> "hello".isupper()
False
>>> "HELLO".isupper()
True
>>> "HELLO123".isupper()
True
>>> "HELLO-34-34".isupper()
True
>>> "HELLO-w".isupper()
False
>>> 


4. isdigit()
	Returns True only when all the characters are numbers; otherwise False.


>>> 
>>> "1234".isdigit()
True
>>> "1234 ".isdigit()
False
>>> "234-123".isdigit()
False
>>> 
>>> "12345678".isalpha()
False
>>> "12345678".isupper()
False
>>> "12345678".islower()
False
>>>


5. startswith(substr)
	- If the string starts with the specified substr then it returns True; otherwise False.


>>> 
>>> quote = "Where there is a will there is a way"
>>> quote.startswith("W")
True
>>> quote.startswith("Where")
True
>>> quote.startswith("Whe")
True
>>> quote.startswith("Where t")
True
>>> quote.startswith("w")
False
>>> quote.startswith("there")
False
>>> 

6. endswith(substr)
	- If the string ends with the specified substr then it returns True; otherwise False.


>>> 
>>> quote
'Where there is a will there is a way'
>>> quote.endswith("y")
True
>>> quote.endswith("ay")
True
>>> quote.endswith("way")
True
>>> quote.endswith("a way")
True
>>> quote.endswith("the way")
False
>>> quote.endswith("z")
False


7. lower()
	- Returns the string where all the letters are converted to lower case.


>>> 
>>> msg = "Message Is: 1234"
>>> msg.lower()
'message is: 1234'
>>> 


8. upper()
	- Returns a string where are the lettes are converted to upper case.


>>> 
>>> msg
'Message Is: 1234'
>>> msg.upper()
'MESSAGE IS: 1234'
>>>


9. title()
	- Returns a string converted to title case.


>>> 
>>> msg = "the meaning of life"
>>> msg.title()
'The Meaning Of Life'
>>> 


10. capitalize()
	-Returns a string in sentence case.



>>> msg = "the meaning of life"
>>> msg.capitalize()
'The meaning of life'



11. lstrip()
	- Removes the whitespace on the left-side of the string and then returns the string.

>>> 
>>> criketer = "       Sachin Tendulkar          "
>>> 
>>> criketer.lstrip()
'Sachin Tendulkar          '


12. rstrip()
	- Removes the whitespaces on the right-side of a string and then returns that string.

>>> 
>>> cricketer = "       Sachin Tendulkar          "
>>> 
>>> cricketer.rstrip()
'       Sachin Tendulkar'


13. strip()
	- Removes whitespaces from a string from both sides, and returns the new string.


>>> 
>>> cricketer = "       Sachin Tendulkar          "
>>> 
>>> cricketer.strip()
'Sachin Tendulkar'
>>> 


14. ljust(width)
	Left justifies the string within the specified width.

>>> 
>>> value = "18,000.00"
>>> 
>>> value.ljust(20)
'18,000.00           '
>>> 


15. rjust(width)
	Right justified the string within the specified width.


>>> 
>>> value = "18,000.00"
>>> 
>>> value.rjust(15)
'      18,000.00'
>>> 


16. center(width)
	Center justified the string within the given width.


>>> 
>>> value = "18,000.00"
>>> 
>>> value.center(30)
'          18,000.00           '
>>> 



Creating a complex password
---------------------------
- one upper case letter
- one lower case letter
- one numeric character
- one special character
- minimum 6 characters, if not specified it takes 12 characters

import random

lowercase = "abcdefghijklmnopqrstuvwxyz"
uppercase = lowercase.upper()
deci_chars = "0123456789"
special_chars = "!@#$%^&*()-_=+[]{}|;':,./<>?"

all_chars = lowercase + uppercase + deci_chars + special_chars

def generate_password(length=12):

	if length < 6:
		return "Password must contain at least 6 characters"

	password = random.choice(lowercase)
	password += random.choice(uppercase)
	password += random.choice(deci_chars)
	password += random.choice(special_chars)

	for _ in range(length - 4):
		password += random.choice(all_chars)

	password_list = list(password)
	random.shuffle(password_list)

	password = "".join(password_list)
	return password




The find() method
==================
find(substr[, start][, end])
	This method find the starting index number of the specified substr within larger string.
	The 'start' is the index number of a string from where you want to start searching for substr, till the index number specified by 'end' argument.
	If the substr is not part of the larger then the method returns -1.



email = "manoj.kumar@gmail.com"

at_index = email.find("@")
at_index
11

>>> dot_index = email.find(".")
>>> dot_index
5
>>> 
>>> dot_index = email.find(".", at_index+1)
>>> dot_index
17
>>> 
>>> email.find("z")
-1
>>> 
>>> if at_index > -1 and at_index < dot_index:
...     print("Valid email", email)
... 
...     
Valid email manoj.kumar@gmail.com
>>> 


The rfind() method
===================
- Same syntax and functionality as the find() method.
- However, it with search for substring from last character of the string.


>>> 
>>> email = "manoj.kumar@gmail.com"
>>> 
>>> at_index = email.find("@")
>>> dot_index = email.rfind(".")
>>> 
>>> at_index
11
>>> dot_index
17
>>> 
>>> if at_index > -1 and at_index < dot_index:
...     print("Valid email address:", email)
... 
...     
Valid email address: manoj.kumar@gmail.com
>>> 


The replace() method
======================
replace(old_substr, new_substr [, num])

	The replace method replaces the old_substr instances with new_substr instances within the larger string.
	The optional [num] parameter specifies the number of occurances to replace.


adr = "1838-3344-3480-5871"
adr.replace("-", " ")
'1838 3344 3480 5871'
adr.replace("-", "")
'1838334434805871'
adr.replace("-", "...")
'1838...3344...3480...5871'
>>> 
>>> adr.replace("-", 2)
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    adr.replace("-", 2)
TypeError: replace() argument 2 must be str, not int
>>> adr.replace("-", " ", 2)
'1838 3344 3480-5871'
>>> 
>>> adr.replace("-", " ", 1)
'1838 3344-3480-5871'
>>> adr.replace("-", " ", 3)
'1838 3344 3480 5871'
>>> 


The split() method
======================
split([delimiter=" "])
	Splits a sting into multiple parts as items in a list.
	By default, the string is split based on space (" ") character.
	However, using the optional parameter delimiter we can specify the delimiter character.



quote = "Anand is personal who is always happy"
quote.split()
['Anand', 'is', 'personal', 'who', 'is', 'always', 'happy']
quote_split = quote.split()
quote_split
['Anand', 'is', 'personal', 'who', 'is', 'always', 'happy']

dt = "2/16/2026"
dt.split()
['2/16/2026']

>>> 
>>> dt = "2/16/2026"
>>> dt.split("/")
['2', '16', '2026']
>>> 
>>> month = int(dt.split("/")[0])
>>> month
2
>>> day = int(dt.split("/")[1])
>>> day
16
>>> year = int(dt.split("/")[2])
>>> year
2026
>>> 


The join() method
==================
str.join(sequence)
	- It joins the items (characters) in the sequence using the specified str.


>>> 
>>> string_list = ['Anand', 'is', 'personal', 'who', 'is', 'always', 'happy']
>>> string_list
['Anand', 'is', 'personal', 'who', 'is', 'always', 'happy']
>>> 
>>> " ".join(string_list)
'Anand is personal who is always happy'
>>> 
>>> "-".join("HYDERABAD")
'H-Y-D-E-R-A-B-A-D'
>>> 


WORKING WITH DATES AND TIMES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The 'datetime' module contains three constructors to construct, date, time, and datetime.

date constructor to construct a date object
time constructor to construct a time object
datetime constructor to construct a datetime object

We import these constructs:
from datetime import date
from datetime import time
from datetime import datetime

	OR

from datetime import date, time, datetime

The today() method from date construct returns current date:

>>> 
>>> today_date = date.today()
>>> today_date
datetime.date(2026, 2, 16)
>>> print(today_date)
2026-02-16
>>> 


The now() method from datetime construct returns current date and time:


>>> 
>>> datetime.now()
datetime.datetime(2026, 2, 16, 10, 19, 3, 714137)
>>> datetime.now()
datetime.datetime(2026, 2, 16, 10, 19, 21, 73068)
>>> datetime.now()
datetime.datetime(2026, 2, 16, 10, 19, 33, 309032)
>>> datetime.now()
datetime.datetime(2026, 2, 16, 10, 20, 2, 127518)
>>> 
>>> nw = datetime.now()
>>> print(nw)
2026-02-16 10:20:25.343174
>>> 


The date construct
--------------------
date(year, month, day)
	- Returns the date specified using the values for year, month, and day.



date(2026, 2, 7)
datetime.date(2026, 2, 7)
>>> bd_date = date(2026, 5, 20)
>>> bd_date
datetime.date(2026, 5, 20)
>>> print(bd_date)
2026-05-20
>>> 
>>> independence_day = date(2026, 8, 15)
>>> independence_day
datetime.date(2026, 8, 15)
>>> 
>>> meeting_day = date(2026, 2, 27)
>>> print(meeting_day)
2026-02-27
>>> 


The time construct
---------------------
time([hour][, minute][, second][, microsecond][tzinfo])
	- This construct returns time object with the specified parameters.

>>> 
>>> time(17, 30, 0, 0)
datetime.time(17, 30)
>>> print(time(17,30,0,0))
17:30:00
>>> 
>>> login_time = time(9, 30)
>>> logout_time = time(18, 30)
>>> print(f"LOGIN TIME: {login_time}\nLOGOUT TIME: {logout_time}")
LOGIN TIME: 09:30:00
LOGOUT TIME: 18:30:00
>>> 


The datetime construct
----------------------
datetime(year, month, day[, hour][, minute][, second][, microsecond])
	- Returns a datetime object with the specified parameters.

>>> 
>>> datetime(2026, 3, 20, 10, 45)
datetime.datetime(2026, 3, 20, 10, 45)
>>> print(datetime(2026, 3, 20, 10, 45))
2026-03-20 10:45:00



Parsing dates times and datetimes
=================================
When the date/time/datetime values are in the form of strings we need to convert them to datetime values.

The datetime construct has a method called strptime(), 'p' in the name of the method stands for 'parsing'.

Syntax for strptime()
---------------------
strptime(datetime_str, format_str)

Common format codes
--------------------
%d	- day number (1-31)
%m	- month number (1-12)
%y	- two-digit year number (26)
%Y	- four-digit year number (2026)
%H	- 24-hour format (0-23)
%M	- minute number (0-59)
%S	- second number (0-59)
%I	- 12-hour format



dt1 = "2/3/2026"
dt2 = "7/6/2026"
dt3 = "2026/15/8"
dt4 = "2026/2/16"
dt5 = "In year 2026, on 2nd month, day 16 I read the article."
dt6 = "At 12:30 I was walking on 16/2/2025"

dt1 = "2/3/2026"
datetime.strptime(dt1, "%d/%m/%Y")
datetime.datetime(2026, 3, 2, 0, 0)
dt1 = datetime.strptime(dt1, "%d/%m/%Y")
print(dt1)
2026-03-02 00:00:00

dt2 = "7/6/2026"
dt2 = datetime.strptime(dt2, "%m/%d/%Y")
print(dt2)
2026-07-06 00:00:00

dt3 = "2026/15/8"
dt3 = datetime.strptime(dt3, "%Y/%d/%m")
print(dt3)
2026-08-15 00:00:00

>>> dt4 = "2026/2/16"
>>> dt4 = datetime.strptime(dt4, "%Y/%m/%d")
>>> print(dt4)
2026-02-16 00:00:00
>>> 
>>> dt5 = "In year 2026, on 2nd month, day 16 I read the article."
>>> dt5 = datetime.strptime(dt5, "In year %Y, on %mnd month, day %d I read the article.")
>>> print(dt5)
2026-02-16 00:00:00
>>> 
>>> dt6 = "At 12:30 I was walking on 16/2/2025"
>>> dt6 = datetime.strptime(dt6, "At %H:%M I was walking on %d/%m/%Y")
>>> print(dt6)
2025-02-16 12:30:00
>>>


Formatting date/time/datetime objects
-------------------------------------
From datetime construct there is a method named strftime, where 'f' stands for 'format'. This method turns a datetime value to a string by formatting it.


Syntax:
datetime_obj.strftime(format_str)

Common format codes
-------------------
%a	Short week name (Sun, Mon, ...)
%A	Full week name (Sunday, Monday, ...)
%b	Short month name (Jan, Feb, Mar, ...)
%B	Full month name (January, February, March, ...)
%d	zero padded day number (01-31)
%m	zero padded month number (01-12)
%y	two-digit year number (26)
%Y	four-digit year number (2026)
%H	24-hour format (0-23)
%I	12-hour format (1-12)
%M	minute number (00-59)
%S	second number (00-59)
%p	AM/PM specifier
%f	microsecond number



special_day = datetime(2026, 10, 22, 19, 45, 10, 888888)
>>> print(special_day)
2026-10-22 19:45:10.888888
>>> 
>>> special_day.strftime("%B %d, %Y (%A)")
'October 22, 2026 (Thursday)'
>>> special_day.strftime("%B %d, %Y (%A) %H:%M %p")
'October 22, 2026 (Thursday) 19:45 PM'
>>> special_day.strftime("%B %d, %Y (%A) %I:%M %p")
'October 22, 2026 (Thursday) 07:45 PM'
>>> special_day.strftime("Time: %I:%M:%S %p Date: %a - %b %d, %Y")
'Time: 07:45:10 PM Date: Thu - Oct 22, 2026'
>>> special_day.strftime("%d-%m-%Y @ %I:%M %p")
'22-10-2026 @ 07:45 PM'
>>> special_day.strftime("%d%m%Y @ %I:%M %p")
'22102026 @ 07:45 PM'
>>> 


WORKING WITH TIME SPANS
*************************
- A timedelta object stores a time span.
- Example: 3 hours; 3 hours & 45 mins; 3 hours, 45 mins, 30 seconds; 20 days; 20 days and 4 hours; 20 days, 4 hours and 4855 microseconds...

- We create timedelta objects by finding difference between 2 date/time/datetime values.



from datetime import date, time, datetime

d1 = date(2026, 8, 17)
d2 = date(2026, 11, 25)
type(d1)
<class 'datetime.date'>
type(d2)
<class 'datetime.date'>
d_diff = d2 - d1
type(d_diff)
<class 'datetime.timedelta'>
print(d_diff)
100 days, 0:00:00

t1 = time(8, 30, 45)
t2 = time(17, 0, 55)
t_diff = t2 - t1
Traceback (most recent call last):
  File "<pyshell#13>", line 1, in <module>
    t_diff = t2 - t1
TypeError: unsupported operand type(s) for -: 'datetime.time' and 'datetime.time'

>>> dt1 = datetime(2026, 2, 17, 9, 45)
>>> dt2 = datetime(2026, 9, 25, 12, 38)
>>> dt_diff = dt2 - dt1
>>> type(dt_diff)
<class 'datetime.timedelta'>
>>> print(dt_diff)
220 days, 2:53:00
>>> 
>>> d_df_diff = dt2 - d1
Traceback (most recent call last):
  File "<pyshell#21>", line 1, in <module>
    d_df_diff = dt2 - d1
TypeError: unsupported operand type(s) for -: 'datetime.datetime' and 'datetime.date'
>>> 


- Create timedelta objects using 'timedelta' construct from datetime module:

from datetime import date, time, datetime, timedelta

Syntax for timedelta:
------------------------
timedetla([days][, seconds][, microseconds][milliseconds][minutes][hours][weeks])

- The timedelta object is measured in days, seconds, and microseconds.



from datetime import date, time, datetime, timedelta

project_duration = timedelta(weeks=6, days=4)
type(project_duration)
<class 'datetime.timedelta'>
print(project_duration)
46 days, 0:00:00
>>> project_duration
datetime.timedelta(days=46)
>>> 
>>> task_duration = timedelta(hours=3, minutes=30)
>>> task_duration
datetime.timedelta(seconds=12600)
>>> print(task_duration)
3:30:00
>>> 
>>> travel_duration = timedelta(weeks=2, days=5, hours=13, minutes=45)
>>> travel_duration
datetime.timedelta(days=19, seconds=49500)
>>> print(travel_duration)
19 days, 13:45:00
>>>


Attributes and a method of a timedelta object
=============================================
1. days
	-> returns number of days in the timedelta object


>>> 
>>> sample_td = timedelta(weeks=8, days=17, hours=2, seconds=18, microseconds=25)
>>> 
>>> sample_td.days
73


2. seconds
	-> returns number of seconds after days

>>> 
>>> sample_td.seconds
7218
>>> 


3. microseconds
	-> returns number of microseconds after days and seconds

>>> 
>>> sample_td.microseconds
25
>>> 


4. total_seconds()
	-> returns total seconds in a timedelta object


>>> 
>>> sample_td.total_seconds()
6314418.000025
>>> 



Some of the attributes of date/time objects
----------------------------------------------
1. year
	-> returns the year number of the
2. month
	-> returns the month number
3. day
	-> returns the day number
4. hour
	-> returns hour number
5. minute
	-> returns the minute number
6. second
	-> returns the seconds number
7. microsecond
	-> returns the microsecond numbers


>>> dt_now = datetime.now()
>>> print(dt_now)
2026-02-17 10:11:22.066724
>>> dt_now.year
2026
>>> dt_now.month
2
>>> dt_now.day
17
>>> dt_now.hour
10
>>> dt_now.minute
11
>>> dt_now.second
22
>>> dt_now.microsecond
66724
>>> 




WORKING WITH DICTIONARY
~~~~~~~~~~~~~~~~~~~~~~~
- A dictionary, unlike a list, is a collection of unordered items.
- The items in a dictionary are surrounded by braces - {}
- And each item has two components: key & value
- Each component is separated by colon: key:value
- The key:value makes one item, and each item is separated by comma (,).
- Dictionary is mutable and efficient compared to list or tuple.

Syntax
--------
{key1:value1, key2:value2, key3:value3, key4:value4, ...}

- We can refer an item using its key value as dictionaries don't have index numbers.
- And keys must be unique in a dictionary. And keys are immutable object types.


Creating a dictionary
----------------------
>>> 
>>> countries = {
...     "IN":"India",
...     "AU":"Australia",
...     "JP":"Japan",
...     "US":"United States",
...     "CA":"Canada"
...     }
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Canada'}
>>> 


Create an empty dictionary
--------------------------
>>> 
>>> catalogue = {}
>>> type(catalogue)
<class 'dict'>
>>> 



Accessing items of a dictionary
-------------------------------
- To access items in a dictionary use key as index to get its value.

dictionary_name[key]


>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Canada'}
>>> countries["IN"]
'India'
>>> countries["CA"]
'Canada'
>>> countries["JP"]
'Japan'
>>> countries["NZ"]
Traceback (most recent call last):
  File "<pyshell#95>", line 1, in <module>
    countries["NZ"]
KeyError: 'NZ'
>>> 


Adding new items to a dictionary
----------------------------------
dictionary_name[newKey] = newValue

>>> 
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Canada'}
>>> countries["UK"] = "United Kingdom"
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Canada', 'UK': 'United Kingdom'}
>>> countries["FR"] = "France"
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Canada', 'UK': 'United Kingdom', 'FR': 'France'}
>>> 


Update existing value of a key in the dictionary
-------------------------------------------------
dictionary_name[key] = newValue

>>> 
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Canada', 'UK': 'United Kingdom', 'FR': 'France'}
>>> countries["CA"] = "Cambodia"
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'UK': 'United Kingdom', 'FR': 'France'}
>>> countries["UK"] = "Ukraine"
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'UK': 'Ukraine', 'FR': 'France'}
>>> 


Checking for a key in a dictionary
------------------------------------
key in dictionary
	-> if key is in the dictionary then it returns True; otherwise False



countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'UK': 'Ukraine', 'FR': 'France'}
countries["IN"]
'India'
countries["SP"]
Traceback (most recent call last):
  File "<pyshell#120>", line 1, in <module>
    countries["SP"]
KeyError: 'SP'

"IN" in countries
True
"SP" in countries
False

if "SP" in countires:
    print("Singapore is in the dictionary")
else:
    countries["SP"] = "Singapore"
    print("Singapore is added to the dictionary")

...     
Traceback (most recent call last):
  File "<pyshell#130>", line 1, in <module>
    if "SP" in countires:
NameError: name 'countires' is not defined. Did you mean: 'countries'?
>>> 
>>> if "SP" in countries:
...     print("Singapore is in the dictionary")
... else:
...     countries["SP"] = "Singapore"
...     print("Singapore is added to the dictionary")
... 
...     
Singapore is added to the dictionary
>>>



Using the get() method
-----------------------
- When a key isn't in the dictionary, then it throws an error (KeyError) which ends the program from executing.
- Use the get() method to avoid KeyError.

Syntax:
dictionary.get(key[, default_value])

If the specified key is the dictionary then it returns the corresponding item. If it is not in the dictionary it returns 'None', or returns default_value it specified.


>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'UK': 'Ukraine', 'FR': 'France', 'SP': 'Singapore'}
>>> countries.get("IN")
'India'
>>> countries.get("IS")
>>> countries.get("IS", "Unknown")
'Unknown'
>>> 
>>> countries.get("FR")
'France'
>>> countries.get("FR", "Unknown")
'France'
>>> countries.get("GP", "Uknown")
'Uknown'
>>> 


Deleting dictionary items
==========================
Three ways to delete items from a dictionary:
1. del	- statement
2. pop() - method
3. clear() - method


del - statement to delete an item from a dictionary
---------------------------------------------------
del dictionary_name[key]
	-> deletes the item with the specified key


>>> 
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'UK': 'Ukraine', 'FR': 'France', 'SP': 'Singapore'}
>>> del countries["UK"]
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'FR': 'France', 'SP': 'Singapore'}
>>> del countries["UK"]
Traceback (most recent call last):
  File "<pyshell#157>", line 1, in <module>
    del countries["UK"]
KeyError: 'UK'
>>> 

pop - to delete an item from a dictionary
-------------------------------------------
pop(key[, default_value])
	-> it returns the value for the specified key. If the doesn't exist it returns None, or the default_value when the second parameter is specified.



countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'CA': 'Cambodia', 'FR': 'France', 'SP': 'Singapore'}
>>> countries.pop("CA")
'Cambodia'
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'FR': 'France', 'SP': 'Singapore'}
>>> countries.pop("CA")
Traceback (most recent call last):
  File "<pyshell#172>", line 1, in <module>
    countries.pop("CA")
KeyError: 'CA'
>>> countries.pop("CA", "Unknown")
'Unknown'
>>> 


clear - to delete all items from a dictionary
--------------------------------------------
dictionary_name.clear()


>>> 
>>> countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'FR': 'France', 'SP': 'Singapore'}
>>> countries.clear()
>>> countries
{}
>>> 


Looping through keys of a dictionary
----------------------------------------
for var in dictionary:
	block

This loops through the keys of the dictionary.


>>> 
>>> countries = {'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'FR': 'France', 'SP': 'Singapore'}
>>> 
>>> for country in countries:
...     print(country, end=" ")
... 
...     
IN AU JP US FR SP 
>>> 


keys() method - access the keys
-------------------------------
We can get the keys of dictionary using keys() method.
Additionally we can loop through the keys just like above.



countries
{'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'FR': 'France', 'SP': 'Singapore'}
countries.keys()
dict_keys(['IN', 'AU', 'JP', 'US', 'FR', 'SP'])
>>> country_codes = list(countries.keys())
>>> country_coes
Traceback (most recent call last):
  File "<pyshell#207>", line 1, in <module>
    country_coes
NameError: name 'country_coes' is not defined. Did you mean: 'country_codes'?
>>> country_codes
['IN', 'AU', 'JP', 'US', 'FR', 'SP']
>>> 
>>> for country in countries.keys():
...     print(country, end=" ")
... 
...     
IN AU JP US FR SP 
>>>


values() method to get all the values
---------------------------------------
We can get the values of dictionary using values() method.
Additionally we can loop through the values just like above.



>>> countries = {'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'FR': 'France', 'SP': 'Singapore'}

>>> countries.values()
dict_values(['India', 'Australia', 'Japan', 'United States', 'France', 'Singapore'])
>>> country_names = countries.values()
>>> country_names
dict_values(['India', 'Australia', 'Japan', 'United States', 'France', 'Singapore'])
>>> 
>>> country_names = list(country_names)
>>> country_names
['India', 'Australia', 'Japan', 'United States', 'France', 'Singapore']
>>> 
>>> for country in countries.values():
...     print(country, end=" ")
... 
...     
India Australia Japan United States France Singapore 


items() method to get items from a dictionary
------------------------------------------------
This method returns items from a dictionary as a tuple where key and value are pairs in the tuple.
Additionally we can loop through the items.


countries = {'IN': 'India', 'AU': 'Australia', 'JP': 'Japan', 'US': 'United States', 'FR': 'France', 'SP': 'Singapore'}

country_tuples = countries.items()
>>> country_tuples
dict_items([('IN', 'India'), ('AU', 'Australia'), ('JP', 'Japan'), ('US', 'United States'), ('FR', 'France'), ('SP', 'Singapore')])
>>> 
>>> for item in countries.items():
...     print(item)
... 
...     
('IN', 'India')
('AU', 'Australia')
('JP', 'Japan')
('US', 'United States')
('FR', 'France')
('SP', 'Singapore')
>>> 



The dict() method to convert other objects to a dictionary
----------------------------------------------------------
>>> 
>>> states = [
...     ["TS", "Telangana"],
...     ["AP", "Andhra Pradesh"],
...     ["TN", "Tamilnadu"],
...     ["KA", "Karnataka"],
...     ["KL", "Kerala"],
...     ["MH", "Maharastra"]
...     ]
>>> states_dict = dict(states)
>>> states_dict
{'TS': 'Telangana', 'AP': 'Andhra Pradesh', 'TN': 'Tamilnadu', 'KA': 'Karnataka', 'KL': 'Kerala', 'MH': 'Maharastra'}
>>> 


Dictionary of dictionaries
--------------------------
In the dictionary of dictionaries, each key is associated with another dictionary.

employees = {
	"1001": {'name':'raju', 'dept':'hr', 'salary':25000.0, 'age':22, 'city':'amr'},
	"1002": {'name':'prasad', 'dept':'sales', 'salary':40000.0, 'age':25, 'city':'che'},
	"1003": {'name':'vinay', 'dept':'it', 'salary':26000.0, 'age':21, 'city':'hyd'},
	"1004": {'name':'anand', 'dept':'hr', 'salary':35000.0, 'age':30, 'city':'tri'}
}


>>> 
>>> employees["1001"]
{'name': 'raju', 'dept': 'hr', 'salary': 25000.0, 'age': 22, 'city': 'amr'}
>>> employees["1001"]["name"]
'raju'
>>> employees["1001"]["dept"]
'hr'
>>> employees["1001"]["salary"]
25000.0
>>> employees["1001"]["age"]
22
>>> employees["1001"]["city"]
'amr'
>>> 



WORKING WITH SETS
~~~~~~~~~~~~~~~~~
- A set is a collection of unordered items without duplicates.
- Syntax:
	{item1, item2, item3, item4, item5, ...}


Creating a set
--------------
>>> 
>>> numbers = {1, 2, 3, 4, 5}
>>> type(numbers)
<class 'set'>
>>> 
>>> 


Creating an empty set
---------------------
>>> 
>>> numbers = set()
>>> numbers
set()
>>> type(numbers)
<class 'set'>
>>> 


Converting a list to set
------------------------
>>> 
>>> # removes the duplicates from the list
>>> items = set([1, 2, 3, 3, 3, 4, 4, 1, 1])
>>> items
{1, 2, 3, 4}
>>> 


Adding an item to a set
-----------------------
Use add(item) to add the specified item to a set


>>> 
>>> courses = {'python', 'pandas'}
>>> courses.add('java')
>>> courses
{'java', 'pandas', 'python'}
>>> 


Adding multiple items to a set
------------------------------
Use update(items_collection]) to add the specified items_collection to the set

>>> 
>>> courses.update(['numpy', 'matplotlib', 'seaborn'])
>>> courses
{'matplotlib', 'seaborn', 'python', 'java', 'numpy', 'pandas'}
>>> 


Remove an item from a set
---------------------------
remove(item) - removes the specified item from the set
		-> If the item is not found then it throws an Error.


>>> 
>>> courses
{'matplotlib', 'seaborn', 'python', 'java', 'numpy', 'pandas'}
>>> courses.remove('java')
>>> courses
{'matplotlib', 'seaborn', 'python', 'numpy', 'pandas'}
>>> courses.remove('perl')
Traceback (most recent call last):
  File "<pyshell#93>", line 1, in <module>
    courses.remove('perl')
KeyError: 'perl'
>>> 


discard(item)	- removes the specified item from the set, if the item is not found then it doesn't throw any error.

>>> 
>>> courses
{'matplotlib', 'seaborn', 'python', 'numpy', 'pandas'}
>>> courses.discard('numpy')
>>> courses
{'matplotlib', 'seaborn', 'python', 'pandas'}
>>> courses.discard('perl')
>>> 


Check membership
----------------
- Use 'in' keyword to check for the membership

>>> 
>>> courses
{'matplotlib', 'seaborn', 'python', 'pandas'}
>>> 'pandas' in courses
True
>>> 'streamlit' in courses
False
>>> 


Set Union (Combines sets)
-------------------------
>>> 
>>> A = {1, 2, 3, 4}
>>> B = {3, 4, 5, 6}
>>> A | B
{1, 2, 3, 4, 5, 6}
>>> A.union(B)
{1, 2, 3, 4, 5, 6}
>>> 


Set Intersection (Common Items)
-------------------------------
>>> 
>>> A = {1, 2, 3, 4}
>>> B = {3, 4, 5, 6}
>>> A & B
{3, 4}
>>> A.intersection(B)
{3, 4}
>>> 


Set Difference (Items in one set but not in other)
---------------------------------------------------
>>> 
>>> A = {1, 2, 3, 4}
>>> B = {3, 4, 5, 6}
>>> A - B
{1, 2}
>>> B - A
{5, 6}
>>> 


Symmetric Difference (Items NOT common)
---------------------------------------
Use the method symmetric_difference() or ^ operator

>>> 
>>> A = {1, 2, 3, 4}
>>> B = {3, 4, 5, 6}
>>> A.symmetric_difference(B)
{1, 2, 5, 6}
>>> 


Loop through a set
-------------------
for var in set:
	block

>>> 
>>> courses = {'matplotlib', 'seaborn', 'python', 'numpy', 'pandas'}
>>> for course in courses:
...     print(course, end=" ")


Copy a set
------------
Use the copy() method to create a copy of a set

>>> 
>>> A = {5, 10, 15, 20, 25}
>>> B = A.copy()
>>> B
{20, 5, 25, 10, 15}
>>> 


Clear a set (Empty items from a set)
------------------------------------
- Use clear() method to empty a set

>>> 
>>> A = {5, 10, 15, 20, 25}
>>> A.clear()
>>> A
set()
>>> 


Frozen Set (immutable set)
--------------------------
Use the frozenset() function to create a immutable set

>>> 
>>> weekdays = frozenset(["sun", "mon", "tue", "wed", "thu", "fri", "sat"])
>>> weekdays
frozenset({'sat', 'mon', 'tue', 'thu', 'wed', 'sun', 'fri'})
>>> type(weekdays)
<class 'frozenset'>
>>> weekdays.add("today")
Traceback (most recent call last):
  File "<pyshell#166>", line 1, in <module>
    weekdays.add("today")
AttributeError: 'frozenset' object has no attribute 'add'
>>> 


Problem
---------
There is a list with duplicate items:
	['hyd', 'amr', 'del', 'che', 'che', 'hyd', 'amr', 'amr', 'che', 'hyd', 'blr', 'blr', 'tri', 'mum', 'tri', 'che', 'hyd', 'blr']

Count the number of occurrences of each city in the list above, and create a dictionary like the following:

Create dictionary:
	{'hyd':4, 'amr':3, 'del':1, 'che':4, 'blr':3, 'tri':2, 'mum':1}



cities = ['hyd', 'amr', 'del', 'che', 'che', 'hyd', 'amr', 'amr', 'che', 'hyd', 'blr', 'blr', 'tri', 'mum', 'tri', 'che', 'hyd', 'blr']
>>> 
>>> cities_set = set(cities)
>>> cities_set
{'che', 'mum', 'amr', 'tri', 'hyd', 'blr', 'del'}
>>> 
>>> cities_count = {}
>>> 
>>> for city in cities_set:
...     cities_count[city] = cities.count(city)
... 
...     
>>> cities_count
{'che': 4, 'mum': 1, 'amr': 3, 'tri': 2, 'hyd': 4, 'blr': 3, 'del': 1}
>>> 



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Projects
============
- No solo projects
- Team-based projects:
	Collaboration
- Version-controlled

Version control:
	- git application
	git-scm.com

Collaboration:
	GitHub.com
	My account: GitHub.com/singamravibabu


Library Management System: Project


Working directory: LibraryMS

LibraryMS/
	.env/		# python virtual environment
	.git/		# git initiated; hidden
	.gitignore	# ignores files not to be pushed
	README.md	# document for the overview of the project
	requirements.txt	# contains libraries to be installed
	main.py		# entry into the application
	database/	# files related to database
		db.py	
	templates/	# HTML files
	static/		# CSS files
	test/		# testing files
		test_main.py	
	docs/		# documentation and help file

Initiating the project...
Create LibraryMS:
	-> Virtual Environment
		python -m venv .env
	-> Activate the virtual environment
		.env\Scripts\activate
		(Always activate virtual environment)
		To deactivate: deactivate
	-> create requirements.txt
		We store all the libraries to be installed
	-> Initialize the git repository
		git init -b main
		(Same repository is created on the GitHub.com)
	-> Connecting to remote repository:
		git remote add origin https://www.github.com/singamravibabu/LibraryMS.git
	-> Verity the remote repository connection:
		git remote -v

main	-> application -> production
	development	-> next version
		- homepage
		- registration
		- databases
		- app1
		- app2
		- docs
		- bugs



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


OBJECT-ORIENTED CODING
~~~~~~~~~~~~~~~~~~~~~~
Objects:
	book, laptop, chair, phone, bike, car, ...
	saving account, insurance product, parent's affection, ...

Aspects of an object:
	1. attributes - characteristics/features: variables
	2. methods - functionalities/actions: functions

phone: object
	attributes: variables
		make = "Samsung" 
		model = "A22"
		weight = 200
		dimensions = (7, 3)
		camera = True
		Bluetooth = True
		....
	methods
		call(to, duration, type)
		take_call(from, duration, type)
		message(to, text, length)
		receive_message(from, text, length)
		send_file(file, type)
		receive_file(file,type)
		connect(pair)
		disconnect(unpair)


The class is a blueprint or template to create an object in a OOP.

We code 'class' with attributes and methods. Then we create 'objects' based on the class. An object is an instance of a class.

Creating a class syntax:

class ClassName:
	block	# attributes and methods


Creating an object based on a class:

var = ClassName()


Once an object is created that object gets the attributes and methods from the class.

Attributes
-----------
# getting

object.attribute1	# reading attribute value
object.attribute2	# reading attribute value
object.attribute3	# reading attribute value

# setting

object.attribute1 = value	# writing attribute value
object.attribute2 = value	# writing attribute value
object.attribute3 = value	# writing attribute value



class Student:
    name = "pupil"
    grade = 1
    age = 5

    
>>>
s1 = Student()
s1.name
'pupil'
s1.grade
1
s1.age
5

s1.name = "anand"
s1.grade = 7
s1.grade = 12

s1.name
'anand'
s1.grade
12
s1.age = 12
s1.grade = 7

s1.name
'anand'
s1.grade
7
s1.age
12

s2 = Student()
s2.name
'pupil'
>>> s2.grade
1
>>> s2.age
5
>>> 
>>> s2.name = "rajesh"
>>> s2.grade = 10
>>> s2.age = 15
>>> 
>>> s2.name
'rajesh'
>>> s2.grade
10
>>> s2.age
15
>>> 


The constructor (method)
--------------------------
__init__()
	- This is a special method (function) used to initiate the attribute values of an object while creating the object.


Syntax:

def __init__(self, param1, param2, param3, ... )
	block

Every method (function) has 'self' as its first parameter. The 'self' represents the object with which you are working.


>>>
>>> class Student:
    def __init__(self, name, grade, age):
...         self.name = name
...         self.grade = grade
...         self.age = age
... 
...         
>>> s1 = Student("prasad", 8, 13)
>>> 
>>> s1.name
'prasad'
>>> s1.grade
8
>>> s1.age
13
>>> 




class Product:
    def __init__(self, name, price, discountPercent):
        self.name = name
        self.price = price
        self.discountPercent = discountPercent

        
p001 = Product('Samsung', 22500.0, 2)

p001.name
'Samsung'
p001.price
22500.0
p001.discountPercent
2






Methods
----------
- Methods are functions coded inside a class. However, methods have some special features.
- Every method has 'self' as it first argument.
- Syntax for using methods:
	object.method_name([args])




class Product:
    def __init__(self, name, price, discountPercent):
        self.name = name
        self.price = price
        self.discountPercent = discountPercent
    def discountAmount(self):
        return self.price * self.discountPercent / 100
    def discountPrice(self):
        return self.price - self.discountAmount()

    
printer = Product("HP Laserjet", 18000.0, 4)
printer.name
'HP Laserjet'
>>> printer.price
18000.0
>>> printer.discountPercent
4
>>> 
>>> printer.discountAmount()
720.0
>>> printer.discountPrice()
17280.0
>>> 
>>> printer
<__main__.Product object at 0x000002769ECB26E0>
>>> print(printer)
<__main__.Product object at 0x000002769ECB26E0>
>>> 
>>> 



class Product:
    def __init__(self, name, price, discountPercent):
        self.name = name
        self.price = price
        self.discountPercent = discountPercent
    def discountAmount(self):
        return self.price * self.discountPercent / 100
...     def discountPrice(self):
...         return self.price - self.discountAmount()
...     def display(self):
...         return f"Name: {self.name}\nPrice: {self.price}\nDiscount percent: {self.discountPercent}\nDiscount amount: {self.discountAmount()}\nDiscount price: {self.discountPrice()}"
... 
...     
>>> p1 = Product("Epson Projector", 48000.0, 5)
>>> p1.display()
'Name: Epson Projector\nPrice: 48000.0\nDiscount percent: 5\nDiscount amount: 2400.0\nDiscount price: 45600.0'
>>> print(p1)
<__main__.Product object at 0x000002769ECB2CB0>
>>> 




class Product:
    def __init__(self, name, price, discountPercent):
        self.name = name
        self.price = price
        self.discountPercent = discountPercent
    def discountAmount(self):
        return self.price * self.discountPercent / 100
...     def discountPrice(self):
...         return self.price - self.discountAmount()
...     def __str__(self):
...         return f"Name: {self.name}\nPrice: {self.price}\nDiscount percent {self.discountPercent}\nDiscount amount: {self.discountAmount()}\nDiscount price: {self.discountPrice()}"
... 
...     
>>> p1 = Product("Epson Projector", 30000.0, 1)
>>> print(p1)
Name: Epson Projector
Price: 30000.0
Discount percent 1
Discount amount: 300.0
Discount price: 29700.0
>>> 



OBJECT-COMPOSITION
~~~~~~~~~~~~~~~~~~
- In the real-world object interact with each other. And we can create composite objects, and their interactions.


Die class
---------
import random

class Die:
	def __init__(self):
		self.value = 1

	def roll(self):
		self.value = random.randint(1, 6)



d1 = Die()
d1.value
1
>>> d1.roll()
>>> d1.value
6
>>> d1.roll()
>>> d1.value
1
>>> d1.roll()
>>> d1.value
3
>>> d1.roll()
>>> d1.value
1
>>> 



class Dice:
	def __init__(self):
		self.list = []

	def addDie(self, die):
		self.list.append(die)

	def rollAll(self):
		for die in self.list:
			die.roll()





d1 = Die()
d2 = Die()
d3 = Die()
d1.value
1
d2.value
1
d3.value
1

dice = Dice()

dice.addDie(d1)
dice.addDie(d2)
dice.addDie(d3)

>>> dice
<__main__.Dice object at 0x000001BCBAB92AA0>
>>> dice.list
[<__main__.Die object at 0x000001BCBAB926E0>, <__main__.Die object at 0x000001BCBAB92B30>, <__main__.Die object at 0x000001BCBAB92BF0>]
>>> 
>>> dice.rollAll()
>>> d1.value
5
>>> d2.value
2
>>> d3.value
2
>>> 


ENCAPSULATION
~~~~~~~~~~~~~~
- Another OOP concept
- To hide the attributes and methods from outside access
- To hide an attribute from the outside add two underscores before the name of the attribute. The attribute becomes private.

Public attribute:
	value
Private attribute:
	__value


The private attribute values are changed /modified using a public method.



class Die:
... 	def __init__(self):
... 		self.__value = 1
... 
... 	def roll(self):
... 		self.__value = random.randint(1, 6)
... 
... 		
>>> die = Die()
>>> die.__value
Traceback (most recent call last):
  File "<pyshell#116>", line 1, in <module>
    die.__value
AttributeError: 'Die' object has no attribute '__value'
>>> 


>>> 
>>> class Die:
...     def __init__(self):
...         self.__value = 1
...     def roll(self):
...         self.__value = random.randint(1, 6)
...     def value(self, value):
...         if value < 1 or value > 6:
...             raise ValueError("Value must be between 1 and 6")
...         else:
...             self.__value = value
... 
...             


Whenever, we use private attributes we may need to use two methods. One is setter method. Other is getter method.

Setter method sets the value of a private attribute
Getter methods gets the value of a private attribute


import random
class Die:
	def __init__(self):
		self.__value = 1

	# setter method
	def setValue(self, value):
		if value < 1 or value > 6:
			raise ValueError("Value must be between 1 and 6")
		else:
			self.__value = value

	# getter method
	def getValue(self):
		return self.__value

	def roll(self):
		self.__value = random.randint(1, 6)




We use annotations to set and get values very easily using something like an attribute, which is actually a method.

object.value		# getter method
object.value = 3	# setter method


@property annotation is used to create getter method
@propertyName.setter annotation is used to create setter method



import random
class Die:
	def __init__(self):
		self.__value = 1

	# getter method
	@property
	def value(self):
		return self.__value

	# setter method
	@value.setter
	def value(self, value):
		if value < 1 or value > 6:
			raise ValueError("Value must be between 1 and 6.")
		else:
			self.__value = value



INHERITANCE
~~~~~~~~~~~~~
A new class created based on an existing class is called a child/derived/subclass which inherits attributes and methods of the existing class. The existing class is called parent/base/superclass.
This concept is called inheritance. Where a child class inherits the attributes and methods of the parent class.

Additionally, child class can add more attributes and methods specific to it.


class Parent:
	...


Syntax for creating a class:
----------------------------
class Child(Parent):
	...



Product: (parent)
	name
	price
	discountPercent
	discountAmount()
	discountPrice()

Book: (child)
	author
	publisher
	edition

Movie: (child)
	release_year
	cast


Parent-Child classes
--------------------
class Product:
	def __init__(self, name, price, discountPercent):
		self.name = name
		self.price = price
		self.discountPercent = discountPercent

	def discountAmount(self):
		return self.price * self.discountPercent / 100

	def discountPrice(self):
		return self.price - self.discountAmount()

class Book(Product):
	def __init__(self, name, price, discountPercent, author):
		Product.__init__(self, name, price, discountPercent)
		self.author = author

class Movie(Product):
	def __init__(self, name, price, discountPercent, year):
		Product.__init__(self, name, price, discountPercent)
		self.year = year



>>>
>>> book1 = Book("Attitude", 250.0, 10, "John Maxwell")
>>> book1.name
'Attitude'
>>> book1.price
250.0
>>> book1.discountPercent
10
>>> book1.author
'John Maxwell'
>>> book1.discountAmount()
25.0
>>> book1.discountPrice()
225.0


Overriding methods of parent class
-----------------------------------
We can override the parent class attributes in the child class.
All we need to do is code the same method in the child class that will override the method for the child class.



class Product:
	def __init__(self, name, price, discountPercent):
		self.name = name
		self.price = price
		self.discountPercent = discountPercent

	def discountAmount(self):
		return self.price * self.discountPercent / 100

	def discountPrice(self):
		return self.price - self.discountAmount()

	def __str__(self):
		return self.name

class Book(Product):
	def __init__(self, name, price, discountPercent, author):
		Product.__init__(self, name, price, discountPercent)
		self.author = author

	def __str__(self):
		return f"{self.name} | {self.author}"

class Movie(Product):
	def __init__(self, name, price, discountPercent, year):
		Product.__init__(self, name, price, discountPercent)
		self.year = year

	def __str__(self):
		return f"{self.name} | {self.year}"


>>> 
>>> product1 = Product("Laptop", 38000.0, 2)
>>> book1 = Book("Learning Python", 1200.0, 20, "Mark Lutz")
>>> movie1 = Movie("Bahubali", 200.0, 0, 2015)
>>> 
>>> print(product1)
Laptop
>>> print(book1)
Learning Python | Mark Lutz
>>> print(movie1)
Bahubali | 2015
>>>



TYPES OF INHERITANCE
---------------------
1. Single inheritance:

class A:
	pass

class B(A):
	pass


2. Multiple inheritance:

class Father:
	pass

class Mother:
	pass

class Child(Father, Mother):
	pass


3. Multi-level inheritance

class A:
	pass

class B(A):
	pass

class C(B):
	pass


4. Hierarchical inheritance

class Animal:
	pass

class Dog(Animal):
	pass

class Cat(Animal):
	pass



class: Employee
	name
	salary
	show_details()

child class: Manager
	bonus()

class Employee:
	def __init__(self, name, salary):
		self.name = name
		self.salary = salary

	def show_details(self):
		return f"Name: {self.name}\nSalary: {self.salary}"

class Manager(Employee):
	def __init__(self, name, salary):
		super().__init__(self, name, salary)

	def bonus(self):
		print("Bonus is", self.salary * 0.2)


BankAccount
	- name
	- balance
	- deposit()
	- show_balance()

SavingAccount
	- add_interest()

CurrentAccount
	- withdraw



class BankAccount:
	def __init__(self, name, balance):
		self.name = name
		self.balance = balance

	def show_balance(self):
		print("Name:", self.name)
		print("Balance:", self.balance)

	def deposit(self, amount):
		self.balance += amount
		print("Deposited amount:", amount)

class SavingAccount(BankAccount):
	def __init__(self, name, balance):
		super().__init__(self, name, balance)

	def add_interest(self):
		interest = self.balance * 0.05
		self.balance += self.balance * interest
		print("Current balance:", self.balance)

class CurrentAccount(BanckAccount):
	def __init__(self, name, balance):
		super().__init__(self, name, balance)

	def withdraw(self, amount):
		if self.balance > amount:
			self.balance -= amount
			print("New balance:", self.balance)
		else:
			self.balace - amount
			print("Overdraft")




