Extension
-------------
py -> Python
ipynb -> Interactive Python Notebook


First Steps
*****************
Literals
=========
- value
- that doesn't need to be interpreted
- obvious, visible, clear

1. Integer literal
-------------------
- A complete number
- No decimal point

age: 25
sugar: 5
hours: 3
walked: 5

examples: 10, -8, 14, 23, 0, -1, 50, -19


2. Floating-point literals
--------------------------
- numbers with decimal point
- floating between two values

weight: 83.4
milk: 0.5
walk: 1.5

example: 5.3, 7.4, 0.0, -11.3, 1.0, -2.0, 3.0

5 and 5.0
3 and 3.0
0 and 0.0


3. Strings (text)
-------------------
- a sequence of characters
- characters are strung together

name: "Omkar"
qualification: "B.Com Computers"
nationality: "Indian"
Gender: "Male"

Identifying text:
--------------------
- Surround it with quotes (single or double)
- Use quotes consistently
- Empty string: "" or ''
- Every character is mapped to a number (Unicode number) and the character is Unicode character.
- space is a character
- They are case-sensitive

A...Z (65...90)
a...z (97...122)

Multi-line strings
-----------------
- surround them triple single or double quotes

"""This is a multiline text"""
'''This is also a multiline text string'''

- They are also called as docstrings as they are used for documentation.


4. Boolean literals
====================
Boolean values: True and False
		: None

- Used to validate a statement/proposition
- Used for decision-making
- Used to control the flow of the program


Operators
============
1. Arithmetic operators
2. Comparison operators
3. Logical operators
4. Text operators (two operators)
5. Assignment operators


Arithmetic Operators
====================
+	Addition
-	Subtraction
*	Multiplication
/	Division
//	Integer (floor) division
%	Remainder (Modulo)
**	Exponent (power)

- Addition, subtraction and multiplication between two integers is an integer.
- Division between two integers is a float.
- Addition, subtraction, multiplication, and division between one float and other can be any value, then the result float.

Operator precedence: PEMDAS
P - Parentheses ()
E - Exponents **
M and D - Multiplication & Division *, /, //, %
A - Addition
S - Subtraction

() Parentheses
[] Brackets
{} Braces

Operator precedence
--------------------
()
**
*, /, //, %
+, -


Comparison (Relational) Operators
==================================
- Use to compare values.
- To relate values
	-> Result is True or False
	-> These operators can also be called Boolean operators

==	Equal to
!=	Not equal
>	Greater than
<	Less than
>=	Greater or equal
<=	Less or equal


100 == 100
True

200 == 100
False

50 != 100
True

50 != 50
False

100 > 10
True

100 > 99.9
True

10 > 100
False

99.9 > 100
False

50 < 80
True

70 < 100
True

99 < 88
False

55 < 1
False

100 >= 100
True

100 >= 99
True

100 >= 200
False

77 >= 25
True

50 <= 200
True

50 <= 50
True

50 <= 10
False

NOTE: Comparison (relational) operators create Boolean expressions, also they create conditions (conditional statements).

Operator precedence
--------------------
()
**
*, /, //, %
+, -
comparison operators



Logical Operators
==================
- Used to combine conditional statements (Boolean expressions)

bool_exp1 logical_operator bool_exp2
logical_operator bool_exp

Three Boolean operators:
- not
- and
- or

The not operator
------------------
not bool_exp

- not is a negation operator
	-> negating is reversing the Boolean expression
	-> Converts True to False, and vice versa.

100 > 50
True

not 100 > 50
False

not True
False

500 < 25
False

not 500 < 25
True

not True
False

not False
True

True
True

not True
False

False
False

not False
True

1 < 2
True

not 1 < 2
False


Class room: 100 students
	program: select 97 students
	one approach: selected names
		name1
		name2
		...
		name97
	second approach: not selected names
		name98
		name99
		name100

Object of 'not' operator is to simplify the work by reversing the order or approach.



The 'and' operator
--------------------
bool_exp1 and bool_exp2
	- When both the Boolean expressions are True, it returns True; otherwise False.

bring pen 'and' paper
to obey my command:
	scenario 1:
		pen only, not paper
	scenario 2:
		paper only, not pen
	scenario 3:
		pen and paper, both
	scenario 4:
		not pen, not paper

JOB NOTIFICATION:
Candidate must be an MBA 'and' must have at least 3yrs of exp
		be1			be2

	be1	and	be2	result
	----	----	----	-------
C1	True	and	True	YES (True)
C2	True	and	False	NO (False)
C3	False	and	True	NO (False)
C4	False	and	False	NO (False)


True and True
True

True and False
False

False and True
False

False and False
False

1 == 1 and 2 == 2
True

1 == 1 and 2 != 2
False

1 != 1 and 2 == 2
False

1 != 1 and 2 != 2
False

True and True and True and True and True
True

True and True and True and False and True
False


The 'or' operator
------------------
bool_exp1 or bool_exp2
	-. The 'or' operator return True when at least one Boolean expression is True; and returns False when all the Boolean are False.


bring pen 'or' marker:
	scenario 1:
		pen only
	scenario 2:
		marker only
	scenario 3:
		pen and marker
	scenario 4:
		brings nothing


JOB NOTIFICATION:
Candidate must be an MBA 'or' must have at least 3yrs of exp
		(be1)			(be2)

	be1	or	be2	Result
	----	----	----	----
C1	True	or	True	YES (True)
C2	True	or	False	YES (True)
C3	False	or	True	YES (True)
C4	False	or	False	NO (False)


True or True
True

True or False
True

False or True
True

False or False
False

1 == 1 or 2 == 2
True

1 == 1 or 2 != 2
True

1 != 1 or 2 == 2
True

1 != 1 or 2 != 2
False

False or False or False or False or True or False or False
True

False or False or False or False or False or False or False
False



Operator precedence
--------------------
()
**
*, /, //, %
+, -
comparison operators
not
and
or


NOTE: True becomes 1 (numeric) and False becomes 0 (numeric) when used in an arithmetic expression.

100 + True
101

100 + False
100


VARIABLES
**********
What is a variable from higher-level view?
- A variable is a container to store a value or an object.

Syntax for creating variables:

var = value
var = object
var = expression
container = value / object / expression

<variable_name> assignment_operator value
(left_side)		=	   (right_side)

= (assignment operator) assigns (stores) the value on the right-side in the variable (container) on the left-side

value: int, float, str, bool
objects: list, tuple, file, etc.
expression: arithmetic, comparison, Boolean 
	Any expression returns a single value:

>>> 100 + 5 - 20 * 3 + (2-4)**4 / 7 * 12 - 400 + 3 * 30
-237.57142857142856


Store values in a variable:

x = 25
y = 30
z = 100

p = "good morning"
q = False
m = 35.7

Update values in a variable:
(When you update with a new value, then old value disappears)

x = 10
x = 20
x = 3.14159
x = 'hyderabad'


Performing operations using variables:

x = 10
y = 20
z = 30

w = x + y + z
w
60

x
10
y
20
z
30


What is the result of comparison expression?
- Result is a Boolean value

What is the object of the 'not' operator?
- Reverse the outcome of a Boolean expression

What are the different types of logical operators?
- They are: not, and, & or

What is a variable in a programming language?
- Container to store a value or an object


Naming variables
================
- Give descriptive names for variables
- A variable shouldn't begin with a number, but it can contain numbers, letters, and underscore (_).

interestRate -> Camel Case
interest_rate -> snake case
InterestRate -> Pascal case

- A variable is case-sensitive
	'A' is not 'a'
- A variable name shouldn't contain spaces
- Don't use keywords for variable names


Compound Assignment Operators
==============================
+=
	- Add a value to a variable and then assign the new value by updating variable value.

x = 1
x += 1


-=
	Subtract a value from a variable and then assign the new value to update the variable value.


*=
	Multiplies the value with the new value and assigns back to the variable.

/=
	Divides the existing value with the new value and assigns the result to the variable.


Line Continuation character - \
=================================
Wherever you want to break a statement into the next line, type '\' line continuation character and then hit 'Return' key.

Comments
===========
Comments are written inside a program. But the don't affect the code. They are a kind of documentation for reviewing the code.
Comments are ignored by the interpreter.
We can write comments on independent lines or inline comments which we at the end of the statement.

Comments begin with hash tag (#)


SEVEN ESSENTIAL FUNCTIONS
**************************
1. type(value/object)
	Returns the class/type of the specified 'value/object'.

2. print([data][, sep=" "][, end="\n"])
	Prints data to the console/shell.

In syntax:
	- anything surrounded by brackets [] is optional most of the time. Optional: data, sep, and end are optional parameters.

Without parameters print() prints an empty line.

Arguments or parameters are separated by comma (,).

[data]	- optional
	- data can be more that one argument to be printed

[sep]	- optional
	- its default value is space " "

[end]	- optional
	- it's default value is new line (\n) character
	- character/string is printed after the last parameter 

Note: "\n" for new line character and "\t" for tab character


3. var = input([prompt])

- Adds interactivity to the program

The input() function:
	waits for the user input
	when user inputs and hits Return key
	converts the input to a string
	then finally assigns it to a var on the left-side

[prompt]	- optional
		- friendly text to guide the end user


4. int(value)
	Converts the specified value (str) to an integer provided the value contains only numeric characters, not even comma and dot.

func( func( func( ) ) )


5. float(value)
	Converts the specified value (str) to a floating-point number provided the value contains only numeric characters and additionally may contain one dot (decimal point).


6. str(value)
	Converts the specified value to a string.

7. round(num[, deci_places])
	Rounds the specified 'num' to the nearest integer.
	Additionally, we can have specific number of deci_places.



String operations
=================
1. Concatenation (text joining)
	+ -> concatenation operator

2 Repeat operator
	* -> repeating a string
	str * int



CONSTRUCTS - To statements into a single unit (blocks of units)
================================================================
Examples: if, for, while, def, class, with, etc.


The if statement (construct)
============================
- Conditional 'Branching' Construct
	- helps to choose one branch or no branch from several branches
	- the choice made based on a condition

Syntax for 'if' statement:
---------------------------
Three clauses: if, elif, else
Block: set of statements which are indented
	indentation is required to imply the statements are part of that particular clause
	all the statements must be equally indented
	removing indentation ends the clause / construct

if bool_exp:
	block
[elif bool_exp:
	block]...
[else:
	block]


if - required clause (1)
elif - optional clause (0 to n)
else - optional clause (0 to 1)


bool_exp
	returns True or False
	- condition, comparison, logical expression, Boolean value, functions (is functions).


if -> [elif] -> [else]

else clause:
	-> the block of else clause is executed only when statements from no clause are executed.


LOOP CONSTRUCTS
*****************
- Executes a block repeatedly
- Two types of loops: 'for' and 'while'
- The 'for' loop
	- collection (countable) loop
	- finite loop
	- each execution of the block is called an iteration
	- for each item in a collection the loop execute the block once

The 'for' loop
***************

Syntax for 'for' construct:

for <var> in <collection>:
	block


for x in [100, 97, 85, 77]:
	print("Great!!")


Additive Identity: 0
Multiplicative Identity: 1
String Identity: ""
Creating collection: []


total = 0
for i in [1, 2, 3, 4, 5]:
    total = total + i

total = 0

i = 1
total = total + i
total = 1

i = 2
total = total + i
total = 3

i = 3
total = total + i
total = 6

i = 4
total = total + i
total = 10

i = 5
total = total + i
total = 15

# Series
---------
AP
GP
HP

1, 2, 3, 4, 5, 6, 7, ..., 10, ..., 100, ..., 50000
2, 5, 8, 11, 14, ...
-3, 0, 3, 6, 9, ...
2, 4, 8, 16, 32, 64, ....
1/2, 1/6, 1/10, 1/14, ....


The range() function/iterator
******************************
Syntax
---------
range([start=0,] stop[, step=1])
	-> this is a pure iterator function
	-> starts giving values from 'start' value till 'stop' value, stop is exclusive, from 'start' to reach 'stop' the function continuously adds 'step' value.

By default, start is 0 and step is 1


range(stop)	-> stop > 0
----------------------------
range(5)	# 0, 1, 2, 3, 4
range(8)	# 0, 1, 2, 3, 4, 5, 6, 7
range(3)	# 0, 1, 2
range(-7)	# wrong


range(start, stop)	-> start < stop
----------------------
range(0, 4)	# 0, 1, 2, 3
range(1, 5)	# 1, 2, 3, 4
range(8, 14)	# 8, 9, 10, 11, 12, 13
range(-3, 3)	# -3, -2, -1, 0, 1, 2
range(-9, -6)	# -9, -8, -7
range(3, -3)	# wrong


range(start, stop, step)
-------------------------
start < stop	step: +ve
start > stop	step: -ve

range(1, 20, 6)		# 1, 7, 13, 19
range(-50, 50, 20)	# -50, -30, -10, 10, 30
range(50, -50, 20)	# wrong
range(10, 100, -30)	# wrong
range(-50, -10, 20)	# -50, -30
range(-30, 30, -8)	# wrong
range(-30, 30, 8)	#


The 'while' loop
*****************
- This loop is an infinite loop
- Runs indefinitely
- More efficient that 'for' loop

while bool_exp:
	block

As long as the bool_exp is True the loop iterates; once the bool_expression becomes False the loop ends.
Before every iteration it checks the condition. If the condition is True then it iterates, False then ends the loop.


for i in range(5):
	print(i, end=" ")

range(0, 5, 1)	start: 0, stop: 5, step: 1


i = 0
while i < 5:
	print(i, end=" ")
	i += 1


0! = 1
1! = 1
2! = 1 x 2 = 2
3! = 1 x 2 x 3 = 6
4! = 1 x 2 x 3 x 4 = 24
5! = 1 x 2 x 3 x 4 x 5 = 120


n = 5
fact = 1
for i in range(1, n+1):
	fact *= i
print("Factorial:", fact)


n = 5
fact = 1
i = 1
while i < n + 1:
	fact *= i
	i += 1
print("Factorial:", fact)


n = int(input("Enter a positive integer: "))
fact = 1
if n == 0 or n == 1:
	fact = 1
	print("Factorial:", fact)
elif n > 1:
	for i in range(1, n+1):
		fact *= i
	print("Factorial:", fact)
else:
	print("We need a positive integer.")


Electrical Units - Current Bill
===============================
1 to 100 ->  1 rupee / unit
101 to 200 -> 2 rupees / unit
201 to 300 -> 3 rupees / unit
301 to 400 -> 4 rupees / unit
400 +	   -> 5 rupees / unit


305 units used
	100 x 1 = 100
	100 x 2 = 200
	100 x 3 = 300
	5 x 4   =  20


Write a program to calculate bill for the specified units


The 'break' statement
======================
- Sometimes we need to stop iterating a loop. Breaking a loop early (prematurely).
- When the loop does what it is intended for then we can break the loop without going through all the iterations.
- We need to break the loop for a reason (condition), which is specified by 'if' statement.
- Use 'break' statement to break a loop

loop
-> if
   -> break


The 'continue' statement
==========================
- Sometimes we need to skip an iteration, means we don't need execute all the statements of a block.
- The 'continue' statement skips an iteration and jumps to the beginning of the loop, to the next iteration.
- Always use the 'continue' statement inside a 'if' statement.

loop
-> if
   -> continue


FUNCTIONS
***********
Built-in functions
	func_name()
Standard Library functions
	module_name.func_name()
Third-party library functions
	library_name.func_name()
	library_name.module_name.func_name()
	library_name.module_name.class_name.func_name()
	library_name.class_name.func_name()
	library -> [module] -> [class] -> [func]
User-Defined Functions (UDFs)

Why functions?
--------------
- To avoid repeating
- To divide a program into smaller parts
- To automate tasks
- To reuse


Syntax:

def func_name([args]):
	block


'def' - to define a function
func_name - name that you give to a function, its same as naming variables
[args]  - args is arguments (optional)
	- args are variable that take inputs from the function call
	- args are inputs provided to the function
block	- statements

To execute a function we need to make a call to the function:
# function call
func_name([args])


Named functions
===============
def voting(name, age):
	print(f"Hello, {name}!")
	if age >= 18:
		print("You can vote.")
	else:
		print(f"Wait for {18-age} year(s).")

# calling function with arguments
voting("Rajesh", 35)

# calling using named arguments
voting(age=35, name="Rajesh")


Optional (default) parameters (arguments)
===========================================
In the function definition, if we set a parameter to a value then that parameter become optional with default value.
When there are parameters in a sequence make last parameters as default parameters.

We can override the default parameter value by provide a value for it. Otherwise it goes with the default value.


The 'return' statement
=======================
So far, function received inputs through arguments of a calling statement. But functions didn't return anything to the calling statement.

We use 'return' statement inside the function to return a value or an object back to the calling statement. And the calling statement will be replaced by the returned value or object.
The 'return' statement ends the function execution.

In real-world applications, most function have 'return' statement coded.




def func1(args):
	func2(args)

def func2(args):
	...

func1(args)


Local and Global Variables
==========================
Global variable:
- Any variable is created outside of any function.
- It can be read (get its value) and written (change/set its value) out side of functions.
- Inside a function its read-only.
- By default, global is accessible every where.
- Using the keyword 'global' we can modify a global inside a function, which is not recommended.

var1 = 0	# global vairable
var1 = 8

def func1():
	var1	# can't change it
	...

def func2():
	var1 = 30	# a new local variable
	...

def func3():
	global var1	# not recommended
	...

var2 = 100	# global variable
var1 = 16
var2 = 99


Local variable:
-------------------
Any variable created inside a function.
Its only accessible inside a function.




def sample():
    print(x)    # global

x = 25  # global
sample()

###########

def sample():
    x = 15      # local
    print(x)    # local

x = 100     # global
sample()
print(x)    # global; prints 100

##########

def sample(x):  # local
    print(x)    # local

x = 50          # global
sample(x)       # global
print(x)        # global

##########

def sample(x, y):       # local x, y
    z = x + y           # local z
    print("Result:", z) # local z

res = sample(10, 20)        # global: res
print("The result is sent back:", res) # global: res

##########

def sample():
    global x    # global: not recommended   
    x = 35      # global

x = 100         # global
sample()
print(x)        # global; x is 35

###########


Module
==========
What is a module in Python?
- A python file with .py extension
- File: temperature.py
- Module: temperature

Modules contain function(s). These modules can be imported to reuse the functions residing in them.

def to_fahrenheit(celsius):
	fahrenheit = (celsius * 9/5) + 32
	return fahrenheit

def to_celsius(fahrenheit):
	celsius =  (fahrenheit - 32) * 5/9
	return celsius



Importing a module
------------------
import module_name
import temperature

We can also import a module with a shorter name, called alias name using 'as' keyword.

import module_name as mn
import temperature as t

How to use function from a module
------------------------------------
import module_name
module_name.func_name([args])

import temperature
temperature.to_celsius(100)

import temperature as t
t.to_celsius(150)

Directly importing function from a module is not recommended.

from module_name import func_name1, func_name2, ...
from module_name import *	# all functions
func_name1([args])		# not recommended


Standard Library Modules
-------------------------
1. random: functions to generate random numbers
2. csv: functions to work with csv files
3. pickle: functions to work with persistent data
4. math: functions for mathematical operations
5. datetime: contains functions to work with data, time, and datetime, additionally timedelta
6. decimal: to create and work with decimal numbers
7. json: to work with json file

The 'random' module
===================
- Contains functions to generate random numbers
- Import the module:
	import random

random()
---------
Returns a random value between 0 and 1, 1 is exclusive.

>>> random.random()
0.6165319594361989
>>> random.random()
0.3152381192062611
>>> random.random()
0.575182095960144
>>> random.random()
0.1986863126427959


randint(min, max)
------------------
Returns number between min and max values, including min and max value.

>>> random.randint(3, 5)
5
>>> random.randint(3, 5)
4
>>> random.randint(3, 5)
5
>>> random.randint(3, 5)
3
>>> random.randint(3, 5)
5


randrange(start, stop[, step])
---------------------------------
- Similar to range() function, but not iterator, it gives number from the range randomly. The 'stop' is exclusive.

>>> random.randrange(2, 11, 2)
8
>>> random.randrange(2, 11, 2)
2
>>> random.randrange(2, 11, 2)
2
>>> random.randrange(2, 11, 2)
6
>>> random.randrange(2, 11, 2)
6
>>> random.randrange(2, 11, 2)
6
>>> random.randrange(2, 11, 2)
8


pi value from 'math' module
============================
Import module:
	import math

>>> import math
>>> math.pi
3.141592653589793



COLLECTIONS
================
There are two types of collections:
- Ordered (sequences)
- Unordered 


List
******
- List is a collection of ordered items. List is a sequence.
- A list is mutable object. A list can be changed.
- A list can contain duplicate items. List is not a set.

Syntax for creating a list
---------------------------
[item1, item2, item3, item4, ...]
mylist = [item1, item2, item3, item4, ...]

- items can be of any datatype

>>> temps = [32.7, 25.9, 35.3, 30.9, 32.0]
>>> temps
[32.7, 25.9, 35.3, 30.9, 32.0]
>>> scores = [99, 100, 85, 77, 29, 88]
>>> scores
[99, 100, 85, 77, 29, 88]
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names
['raju', 'anand', 'shiva', 'charan']
>>> emp_details = ["raju", "1003", 35, "hr", "hyd", 38000.0, 2, True]
>>> emp_details
['raju', '1003', 35, 'hr', 'hyd', 38000.0, 2, True]


>>> # empty list
>>> marks = []

>>> # a list with default values
>>> sub_scores = [0] * 6
>>> sub_scores
[0, 0, 0, 0, 0, 0]


Accessing items from a list
============================
As list is a sequence, so the items are referred using index numbers.
First item index is 0, second item index is 1, third item index is 2, so on and so forth.
We can also refer items from last to first, last item index is -1, second last item index is -2, third last item index is -3, so on and so forth.

Syntax for accessing item in a list
------------------------------------
list_name[index_number]		# [] is index operator



emp_names = ["raju", "anand", "shiva", "charan"]
emp_names[0]
'raju'
emp_names[1]
'anand'
emp_names[2]
'shiva'
emp_names[3]
'charan'
emp_names[4]
Traceback (most recent call last):
  File "<pyshell#72>", line 1, in <module>
    emp_names[4]
IndexError: list index out of range


>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names[-1]
'charan'
>>> emp_names[-2]
'shiva'
>>> emp_names[-3]
'anand'
>>> emp_names[-4]
'raju'
>>> emp_names[-5]
Traceback (most recent call last):
  File "<pyshell#79>", line 1, in <module>
    emp_names[-5]
IndexError: list index out of range


Objects: int, float, str, bool, list, tuple, set, dict, array, file, ...


#######################
Objects:
	attributes: characteristics, features
	methods: functions, actions

human:
	ATTRIBUTES: variables
	name = "anand"
	age = 25
	gender = "male"
	nationality = "Indian"
	ethnicity = "Asian"
	weight = 53
	height = 165
	color = "wheatish"
	education = "graduate"
	METHODS: functions
	run(direction, duration, speed)
	walk(time, type, duration)
	sit(location, com_type, ...)
	eat(num, type, amount, nutrition, calories, ...)
	read(genre, purpose, notes, ...)
	jump(height, num, ...)

book:
	ATTRIBUTES:
	author = "satish"
	publisher = "wiley"
	year = 2026
	pages = 385
	chapters = 12
	book_type = "hardbound"
	genre = "non-fiction"
	METHODS:
	open()
	bookmark()
	foldpage()
	tearpage()

Using attributes and methods of an object:
	object.attribute 	-> value
	book.author		-> satish
	object.attribute = newValue
	book.publisher = "routledge"
	object.method([args])

Difference between method and function:
function(object)	# object is an input
object.method()		# operates on input

#######################

Set a new item in the place of an existing item
-----------------------------------------------
my_list[index] = newItem

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names[0] = "prasad"
>>> emp_names
['prasad', 'anand', 'shiva', 'charan']
>>> 



Methods of a list object
=========================
1. append(item)
	Appends the specified item to the end of the list.

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names.append("omkar")
>>> emp_names
['raju', 'anand', 'shiva', 'charan', 'omkar']
>>> emp_names.append("satish")
>>> emp_names
['raju', 'anand', 'shiva', 'charan', 'omkar', 'satish']
>>> emp_names.append("akanksha")
>>> emp_names
['raju', 'anand', 'shiva', 'charan', 'omkar', 'satish', 'akanksha']
>>>


2. insert(index, item)
	Inserts the specified item at the specified index.

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan"]
>>> emp_names.insert(1, "manoj")
>>> emp_names
['raju', 'manoj', 'anand', 'shiva', 'charan']
>>> 
>>> emp_names.insert(0, "omkar")
>>> emp_names
['omkar', 'raju', 'manoj', 'anand', 'shiva', 'charan']
>>> emp_names.insert(4, "akanksha")
>>> emp_names
['omkar', 'raju', 'manoj', 'anand', 'akanksha', 'shiva', 'charan']
>>>



3. index(item)
	Returns the index number of the first occurrence of the specified item.


>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan", "raju", "anand", "raju", "shiva"]
>>> 
>>> emp_names.index("raju")
0
>>> emp_names.index("anand")
1
>>> emp_names.index("charan")
3
>>>


4. remove(item)
	Deletes the first occurrence of specified item.

>>> 
>>> emp_names = ["raju", "anand", "shiva", "charan", "raju", "anand", "raju", "shiva"]
>>> emp_names.remove("raju")
>>> emp_names
['anand', 'shiva', 'charan', 'raju', 'anand', 'raju', 'shiva']
>>> emp_names.remove("anand")
>>> emp_names.remove("charan")
>>> emp_names.remove("rajesh")
Traceback (most recent call last):
  File "<pyshell#139>", line 1, in <module>
    emp_names.remove("rajesh")
ValueError: list.remove(x): x not in list
>>>


5. pop([index])
	Removes the last item if the index is not specified.
	If the index is specified then it removes item at the specified index.
	Before it removes the item it returns the item and then removes it.


>>> 
>>> cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
>>> cities.pop()
'mum'
>>> cities
['hyd', 'amr', 'che', 'blr', 'tri']
>>> 
>>> cities
['hyd', 'amr', 'che', 'blr', 'tri']
>>> 
>>> removed_item = cities.pop()
>>> removed_item
'tri'
>>> 
>>> cities
['hyd', 'amr', 'che', 'blr']
>>> 
>>> cities.pop(2)
'che'
>>>


The 'len()' function
====================
len(collection)
	counts the number of items in the collection and returns that number.

>>> 
>>> cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
>>> 
>>> len(cities)
7
>>>



'in' - membership keyword
=========================
Syntax
---------
item in list
	If 'item' in 'list' it returns True; otherwise False.


item in tuple
sub_str in str



cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
"hyd" in cities
True
"che" in cities
True
"del" in cities
False
"kol" in cities
False


if "hyd" in cities:
    print("Hyderabad is in the list")
else:
...     cities.append("hyd")
... 
...     
Hyderabad is in the list
>>> 
>>> if "kol" in cities:
...     print("Kolkatta is in the list")
... else:
...     cities.append("kol")
...     print("Kolkatta is added")
... 
...     
Kolkatta is added
>>> cities
['hyd', 'amr', 'che', 'blr', 'tri', 'mum', 'bhu', 'kol']
>>>


Looping through the items in a list
====================================
for item in list:
	block

>>> 
>>> cities = ["hyd", "amr", "che", "blr", "tri", "mum", "bhu"]
>>> 
>>> for city in cities:
...     print(city, end=" ")
... 
...     
hyd amr che blr tri mum bhu 
>>>


List of lists
================

One employee:
["anand", 20, "hr", 22000.0, "suryapet", False]


More that one employee: list of lists:
[
["anand",  85, 80, 75],
["shiva",  88, 90, 80],
["omkar",  75, 85, 95],
["satish", 80, 90, 70],
["manoj",  80, 80, 80],
]

To refer items in the list use index as usual:
list[index]
To refer items in the sublists use index of index:
list[index][index]



>>> student_marks[0]
['anand', 85, 80, 75]
>>> student_marks[0][0]
'anand'
>>> 
>>> student_marks[1]
['shiva', 88, 90, 80]
>>> student_marks[1][0]
'shiva'
>>> student_marks[1][1]
88
>>> student_marks[1][2]
90
>>> student_marks[1][3]
80
>>>


More list methods
*******************
1. count(item)
	-> Counts the number of occurrences of the specified item in the list, and returns the number.


>>> 
>>> students = ["praveen", "naveen", "suresh", "naveen", "uday", "naveen", "suresh"]
>>> 
>>> students.count("praveen")
1
>>> students.count("naveen")
3
>>> students.count("suresh")
2
>>> students.count("anand")
0
>>>


2. reverse()
	- Reverses the order of items in a list.

>>> 
>>> students = ["praveen", "naveen", "suresh", "naveen", "uday", "naveen", "suresh", "krishna", "srinu", "anil", "prasad"]
>>> 
>>> students.reverse()
>>> students
['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen']
>>> 


3. sort([key=function][, reverse=False])
	Sort the items in a list by default is ascending order.
	Additionally, we can specify a function before sorting the items using 'key' parameter.
	Use the 'reverse' parameter for ascending and descending.


>>> 
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> students.sort()
>>> students
['Mahesh', 'anil', 'krishna', 'naveen', 'naveen', 'naveen', 'prasad', 'praveen', 'srinu', 'suresh', 'suresh', 'uday']
>>> 


>>> 
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> students.sort(key=str.lower)
>>> students
['anil', 'krishna', 'Mahesh', 'naveen', 'naveen', 'naveen', 'prasad', 'praveen', 'srinu', 'suresh', 'suresh', 'uday']
>>> 

>>> 
>>> students.sort(key=str.lower, reverse=True)
>>> students
['uday', 'suresh', 'suresh', 'srinu', 'praveen', 'prasad', 'naveen', 'naveen', 'naveen', 'Mahesh', 'krishna', 'anil']
>>> 




The built-in function: sorted(list[, key=function])
====================================================
- This function returns a new sorted list.

>>> 
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> students_sorted = sorted(students, key=str.upper)
>>> students_sorted
['anil', 'krishna', 'Mahesh', 'naveen', 'naveen', 'naveen', 'prasad', 'praveen', 'srinu', 'suresh', 'suresh', 'uday']
>>> students
['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', 'Mahesh']
>>> 


Two built-in functions: min() & max()
======================================
- Find the min and max values from a numeric list.


>>> 
>>> numbers = [10, 8, 25, 10, 15, 75, 1]
>>> min(numbers)
1
>>> max(numbers)
75
>>> 


choice() function from random module
====================================
- This function chooses one item randomly from the list.

import random
random.choice(list)


>>> 
>>> import random
>>> students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]
>>> 
>>> random.choice(students)
'naveen'
>>> random.choice(students)
'suresh'
>>> random.choice(students)
'suresh'
>>> random.choice(students)
'naveen'
>>> random.choice(students)
'naveen'
>>>


shuffle() function from random module
======================================
- It shuffles the items randomly in a list

import random
random.shuffle(list)



import random
students = ['prasad', 'anil', 'srinu', 'krishna', 'suresh', 'naveen', 'uday', 'naveen', 'suresh', 'naveen', 'praveen', "Mahesh"]

random.shuffle(students)
students
['srinu', 'krishna', 'prasad', 'praveen', 'anil', 'naveen', 'Mahesh', 'suresh', 'naveen', 'suresh', 'naveen', 'uday']
>>> 
>>> random.shuffle(students)
>>> students
['prasad', 'suresh', 'praveen', 'naveen', 'naveen', 'suresh', 'uday', 'srinu', 'krishna', 'naveen', 'anil', 'Mahesh']
>>> random.shuffle(students)
>>>
>>> students
['naveen', 'prasad', 'naveen', 'suresh', 'krishna', 'anil', 'suresh', 'praveen', 'srinu', 'naveen', 'Mahesh', 'uday']
>>> 
>>> random.shuffle(students)
>>> students
['srinu', 'suresh', 'krishna', 'naveen', 'prasad', 'anil', 'naveen', 'Mahesh', 'naveen', 'praveen', 'uday', 'suresh']
>>>


List copying
================
Two types:

- Shallow copy
	In shallow copy we assign a list to a variable and then we assign that variable to a new variable. Now, both the variables point to the same list.
	This is called shallow copy.


# shallow copy
a = [1, 2, 3]
b = a
a
[1, 2, 3]
>>> b
[1, 2, 3]
>>> 
>>> a.append(4)
>>> a
[1, 2, 3, 4]
>>> b
[1, 2, 3, 4]
>>> a.append(5)
>>> b.append(6)
>>> a
[1, 2, 3, 4, 5, 6]
>>> b
[1, 2, 3, 4, 5, 6]
>>> 


- Deep copy
	Deepcopy is created using the deepcopy() function from copy module.
	Deepcopy is a actually a separate copy of a list.



import copy
>>> m = [1, 2, 3]
>>> n = copy.deepcopy(m)
>>> 
>>> m.append(4)
>>> m
[1, 2, 3, 4]
>>> n
[1, 2, 3]
>>> 
>>> n.append(40)
>>> n
[1, 2, 3, 40]
>>> m
[1, 2, 3, 4]
>>> 


Slicing a list
================
my_list[start:end:step]
	start is 0 (by default)
	step is 1 (by default)
	end is exclusive


>>> numbers = [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]
>>> 
>>> numbers[0:5]
[5, 10, 15, 20, 25]
>>> numbers[0:]
[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]
>>> numbers[0::2]
[5, 15, 25, 35, 45, 55]
>>> numbers[1::2]
[10, 20, 30, 40, 50, 60]
>>> numbers[1:-1:3]
[10, 25, 40, 55]
>>> numbers[::-1]
[60, 55, 50, 45, 40, 35, 30, 25, 20, 15, 10, 5]
>>> 



Concatenating lists
====================
books1 = ["Attitude", "Leadership", "Management"]
books2 = ["Python" "Power BI", "Excel"]

books = books1 + books2

>>> 
>>> books1 = ["Attitude", "Leadership", "Management"]
>>> books2 = ["Python", "Power BI", "Excel"]
>>> books = books1 + books2
>>> 
>>> books
['Attitude', 'Leadership', 'Management', 'Python', 'Power BI', 'Excel']
>>> 


# extending a list using concatenation
>>> 
>>> books1 += books2
>>> books1
['Attitude', 'Leadership', 'Management', 'Python', 'Power BI', 'Excel']
>>> 




WORKING WITH TUPLES
********************
- Tuple is a sequence of items like a list object.
- Unlike list, tuple is immutable, you cannot:
	- change items
	- add items
	- delete items
	- reverse the items
	- sort the items
- Syntax for tuple:

(item1, item2, item3, ... )
my_tuple = (item1, item2, item3, ... )




>>> products = ("saving", "fd", "rd", "insurance", "bonds")
>>> # append doesn't work
>>> products.append("vehicle insurance")
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    products.append("vehicle insurance")
AttributeError: 'tuple' object has no attribute 'append'
>>> # pop doesn't work
>>> products.pop()
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    products.pop()
AttributeError: 'tuple' object has no attribute 'pop'
>>> # assignment to an item doesn't work
>>> products[0] = "savings"
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    products[0] = "savings"
TypeError: 'tuple' object does not support item assignment
>>> 
>>> 


Accessing item of a tuple
==========================
- Use the index number to access the items of a tuple.
- Index 0 is first item, index 1 is second item, index 2 is third item, so on and so forth.
- Index -1 is last item, index -2 is second last item, index -3 is third last item, so on and so forth.




products
('saving', 'fd', 'rd', 'insurance', 'bonds')
products[0]
'saving'
products[1]
'fd'
products[3]
'insurance'
>>> products[-1]
'bonds'
>>> products[-2]         
'insurance'
>>>


>>> 
>>> # count(item) to count the specified
>>> products.count("insurance")
1
>>> 
>>> # my_tuple[start:end:step] - slicing
>>> products[1:]
('fd', 'rd', 'insurance', 'bonds')
>>>



Unpacking items in a list/tuple
*******************************
If a list/tuple contains 10 items, then you can assign them to 10 variable using one single statement.



>>> products = ("laptop", "printer", "scanner", "webcam")

>>>> p1, p2, p3, p4 = products
>>> p1
'laptop'
>>> p2
'printer'
>>> p3
'scanner'
>>> p4
'webcam'
>>> 
>>> 
>>> weekdays = ["mon", "tue", "wed", "thu", "fri"]
>>> w1, w2, w3, w4, w5 = weekdays
>>> w1
'mon'
>>> w2
'tue'
>>> w3
'wed'
>>> 
>>> 


The list() function
===================
- Creates a new list object based on the given object.

>>> 
>>> products = ("laptop", "printer", "scanner", "webcam")
>>> products_list = list(products)
>>> products_list
['laptop', 'printer', 'scanner', 'webcam']
>>> 
>>> 

The tuple() function
====================
- Creates a new tuple object based on the given object.

>>> 
>>> weekdays = ["mon", "tue", "wed", "thu", "fri"]
>>> weekdays_tuple = tuple(weekdays)
>>> weekdays_tuple
('mon', 'tue', 'wed', 'thu', 'fri')
>>> 


WORKING WITH FILES
********************
In Python, there are two types of files:
	- text files
	- binary files

Text files
-----------
- A text file is a sequence of lines, each line contains characters, at the end of each line there is new line (\n) character.
- .txt, .csv, .html, .xml, .json


Binary files
------------
- A binary file is a sequence of bytes. And it may contain text parts.
- image, voice, video, compressed, compiled, etc.


Text files
***********
File operations
=================
1. Open the file
	- Use the built-in function: open()
2. Read from the file or write to the file
	- To read there are read methods
	- To write we have write() method
3. Close the file
	- Use the close() method

Note: Always close the file which opened.


.	current folder
..	parent folder

project/
	files/
		hello.txt
		docs/
	access_file.py
	test_scenarios.txt



access_file.py
	. (current folder)	project/
	./files			project/files
	./files/hello.txt	project/files/hello.txt
	../			parent folder of project
	test_scenarios.txt	Right
	./test_scenarios.txt	Appropriate (practical)

The open() function
********************
Syntax
-----------
open(file, mode)
	- This function opens the specified file in the specified mode.
	- file: file_name (may include path)
	- mode: specifies how we can work the file

File modes
-------------
1. r (read) mode
	- We can read the file if it exists. If the file does not exist, then it throws FileNotFoundError.

2. w (write) mode
	- If the file doesn't exist it creates a new file
	- If the file already exists then it erases all the data from the file
	- Then we can write new data

3. a (append) mode
	- If the file doesn't exist then it creates a new file
	- If the file already exists then we can append the new data to the end of the file.

4. b (binary) mode
	- Use binary mode (b) with read (rb) and write (wb) mode



